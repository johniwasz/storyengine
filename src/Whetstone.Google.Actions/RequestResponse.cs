// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using Whetstone.Google.Actions.V1;
//
//    var action = Action.FromJson(jsonString);

namespace Whetstone.Google.Actions.V1
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    //public partial class Action
    //{
    //    [JsonProperty("request", NullValueHandling = NullValueHandling.Ignore)]
    //    public HandlerRequest Request { get; set; }

    //    [JsonProperty("response", NullValueHandling = NullValueHandling.Ignore)]
    //    public HandlerResponse Response { get; set; }
    //}

    /// <summary>
    /// Represents a request sent to a developer's fulfillment by Google.
    /// </summary>
    public partial class HandlerRequest
    {
        /// <summary>
        /// Optional. Information of current context of the request. Includes but isn't limited
        /// to active media session info or canvas info.
        /// </summary>
        [JsonProperty("context", NullValueHandling = NullValueHandling.Ignore)]
        public Context Context { get; set; }

        /// <summary>
        /// Required. Info on the device the user is using to interact with the Action.
        /// </summary>
        [JsonProperty("device", NullValueHandling = NullValueHandling.Ignore)]
        public Device Device { get; set; }

        /// <summary>
        /// Required. Information to fulfillment on how to handle the request. For
        /// example a request intending to get a fact might have a handler with a name
        /// of "getFact".
        /// </summary>
        [JsonProperty("handler", NullValueHandling = NullValueHandling.Ignore)]
        public Handler Handler { get; set; }

        /// <summary>
        /// Optional. Information related to the HomeGraph structure that the target device
        /// belongs to. See
        /// https://developers.google.com/actions/smarthome/concepts/homegraph.
        /// </summary>
        [JsonProperty("home", NullValueHandling = NullValueHandling.Ignore)]
        public Home Home { get; set; }

        /// <summary>
        /// Required. Represents the last matched intent.
        /// </summary>
        [JsonProperty("intent", NullValueHandling = NullValueHandling.Ignore)]
        public Intent Intent { get; set; }

        /// <summary>
        /// Optional. Info on the current and next scene when the function was called.
        /// Will be filled when the fulfillment call is made
        /// within the scope of a scene.
        /// </summary>
        [JsonProperty("scene", NullValueHandling = NullValueHandling.Ignore)]
        public Scene Scene { get; set; }

        /// <summary>
        /// Required. Holds session data like the session id and session parameters.
        /// </summary>
        [JsonProperty("session", NullValueHandling = NullValueHandling.Ignore)]
        public Session Session { get; set; }

        /// <summary>
        /// Required. User who initiated the conversation.
        /// </summary>
        [JsonProperty("user", NullValueHandling = NullValueHandling.Ignore)]
        public User User { get; set; }
    }

    /// <summary>
    /// Optional. Information of current context of the request. Includes but isn't limited
    /// to active media session info or canvas info.
    ///
    /// Contains context information when user makes query. Such context includes but
    /// not limited to info about active media session, state of canvas web app, etc.
    /// </summary>
    public partial class Context
    {
        /// <summary>
        /// Contains context information about current canvas.
        /// </summary>
        [JsonProperty("canvas", NullValueHandling = NullValueHandling.Ignore)]
        public CanvasContext Canvas { get; set; }

        /// <summary>
        /// Contains context information about current active media session.
        /// </summary>
        [JsonProperty("media", NullValueHandling = NullValueHandling.Ignore)]
        public MediaContext Media { get; set; }
    }

    /// <summary>
    /// Contains context information about current canvas.
    /// </summary>
    public partial class CanvasContext
    {
        /// <summary>
        /// Optional. State set by 3P Interactive Canvas app. This is only set for request, not for
        /// response. For example, if this is a recipe app, the state can be a value of struct : {
        /// "current_page" : 5, "last_page" : 3, } The size limit is 50KB.
        /// </summary>
        [JsonProperty("state")]
        public dynamic State { get; set; }
    }

    /// <summary>
    /// Contains context information about current active media session.
    /// </summary>
    public partial class MediaContext
    {
        /// <summary>
        /// Media progress of current active media file.
        /// </summary>
        [JsonProperty("progress", NullValueHandling = NullValueHandling.Ignore)]
        public string Progress { get; set; }
    }

    /// <summary>
    /// Required. Info on the device the user is using to interact with the Action.
    ///
    /// Represents the device the user is using to make a request to the Action.
    ///
    /// Optional. Use to move between Assistant devices the user has access to.
    /// </summary>
    public partial class Device
    {
        /// <summary>
        /// Required. the capabilities of the device making a request to the Action.
        /// </summary>
        [JsonProperty("capabilities", NullValueHandling = NullValueHandling.Ignore)]
        public List<Capability> Capabilities { get; set; }
    }

    /// <summary>
    /// Required. Information to fulfillment on how to handle the request. For
    /// example a request intending to get a fact might have a handler with a name
    /// of "getFact".
    ///
    /// Represents a fulfillment handler that maps event information
    /// from Actions on Google to fulfillment. Use the handler name to determine what
    /// code you should run in fulfillment.  For instance, a handler might be
    /// used to get information on a user's order information with a handler name
    /// like "OrderLookup" while another might get product information from a
    /// database, with a handler name like "GetProductInfo".
    /// </summary>
    public partial class Handler
    {
        /// <summary>
        /// Optional. The name of the handler.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }
    }

    /// <summary>
    /// Optional. Information related to the HomeGraph structure that the target device
    /// belongs to. See
    /// https://developers.google.com/actions/smarthome/concepts/homegraph.
    ///
    /// Represents the HomeGraph structure that the user's target device belongs to.
    ///
    /// Optional. Used to specify parameters related to the HomeGraph structure
    /// that the target device belongs to. See
    /// https://developers.google.com/actions/smarthome/concepts/homegraph.
    /// </summary>
    public partial class Home
    {
        /// <summary>
        /// Optional. List of parameters associated with the HomeGraph structure the target
        /// device belongs to.
        /// </summary>
        [JsonProperty("params", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, dynamic> Params { get; set; }
    }

    /// <summary>
    /// Required. Represents the last matched intent.
    ///
    /// Represents an intent.
    /// </summary>
    public partial class Intent
    {
        /// <summary>
        /// Required. The name of the last matched intent.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Required. Represents parameters identified as part of intent matching.
        /// This is a map of the name of the identified parameter to the value of the
        /// parameter identified from user input. All parameters defined in
        /// the matched intent that are identified will be surfaced here.
        /// </summary>
        [JsonProperty("params", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, dynamic> Params { get; set; }

        /// <summary>
        /// Optional. Typed or spoken input from the end user that matched this intent.
        /// This will be populated when an intent is matched, based on the user input.
        /// </summary>
        [JsonProperty("query", NullValueHandling = NullValueHandling.Ignore)]
        public string Query { get; set; }
    }

    /// <summary>
    /// Optional. Info on the current and next scene when the function was called.
    /// Will be filled when the fulfillment call is made
    /// within the scope of a scene.
    ///
    /// Represent a scene. Scenes can call fulfillment, add prompts, and collect slot
    /// values from the user. Scenes are triggered by events or intents and can
    /// trigger events and match intents to transition to other scenes.
    ///
    /// Optional. Represents the current and next scene. If `Scene.next` is set
    /// the runtime will immediately transition to the specified scene.
    /// </summary>
    public partial class Scene
    {
        /// <summary>
        /// Required. Name of the current scene.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Optional. Information on the scene to be executed next.
        /// </summary>
        [JsonProperty("next", NullValueHandling = NullValueHandling.Ignore)]
        public NextScene Next { get; set; }

        /// <summary>
        /// Required. The current status of slot filling. This field is read-only.
        /// </summary>
        [JsonProperty("slotFillingStatus", NullValueHandling = NullValueHandling.Ignore)]
        public SlotFillingStatus? SlotFillingStatus { get; set; }

        /// <summary>
        /// The slots associated with the current scene. Handler responses cannot
        /// return slots which were not sent in the request.
        /// </summary>
        [JsonProperty("slots", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, dynamic> Slots { get; set; }
    }

    /// <summary>
    /// Optional. Information on the scene to be executed next.
    ///
    /// Represents the scene to be executed next.
    /// </summary>
    public partial class NextScene
    {
        /// <summary>
        /// Name of the scene to be executed next.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }
    }

    /// <summary>
    /// Required. Holds session data like the session id and session parameters.
    ///
    /// Contains information on the current conversation session
    ///
    /// Optional. Describes data for the current session, session
    /// parameters can be created, updated, or removed by the fulfillment.
    /// </summary>
    public partial class Session
    {
        /// <summary>
        /// Required. Globally unique ID of the current conversation session.
        /// This field is read-only.
        /// </summary>
        [JsonProperty("id", NullValueHandling = NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// Language of the current conversation session. Follows IETF BCP-47 language
        /// code http://www.rfc-editor.org/rfc/bcp/bcp47.txt.
        /// This could be different from user locale if the action uses multi-language
        /// features. For example, when handler_response.expected.language is set, it
        /// changes the conversation language for all following turns, which will be
        /// reflected in this field.
        /// </summary>
        [JsonProperty("languageCode", NullValueHandling = NullValueHandling.Ignore)]
        public string LanguageCode { get; set; }

        /// <summary>
        /// Required. List of all parameters collected from forms and intents during
        /// the session. Key is the parameter name.
        /// Parameters defined here will be merged
        /// with parameters already defined in the session.
        /// Parameters with a null value will be removed from the session.
        /// </summary>
        [JsonProperty("params", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, dynamic> Params { get; set; }

        /// <summary>
        /// Optional. Types scoped to the session.
        /// Session type defines can supplement or replace existing types.
        /// Type names must be unique.
        /// </summary>
        [JsonProperty("typeOverrides", NullValueHandling = NullValueHandling.Ignore)]
        public List<TypeOverride> TypeOverrides { get; set; }
    }

    /// <summary>
    /// Represents an override for a type.
    /// </summary>
    public partial class TypeOverride
    {
        /// <summary>
        /// Required. How this type should be merged with other type values.
        /// </summary>
        [JsonProperty("mode", NullValueHandling = NullValueHandling.Ignore)]
        public Mode? Mode { get; set; }

        /// <summary>
        /// Required. Name of the type to supplement or override.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        [JsonProperty("synonym", NullValueHandling = NullValueHandling.Ignore)]
        public SynonymType Synonym { get; set; }
    }

    /// <summary>
    /// Represents a type with synonyms.
    /// </summary>
    public partial class SynonymType
    {
        /// <summary>
        /// Required. List of entries for the synonym type.
        /// </summary>
        [JsonProperty("entries", NullValueHandling = NullValueHandling.Ignore)]
        public List<Entry> Entries { get; set; }
    }

    /// <summary>
    /// Represents a entry for a synonym type.
    /// </summary>
    public partial class Entry
    {
        /// <summary>
        /// Optional. The item display's information.
        /// </summary>
        [JsonProperty("display", NullValueHandling = NullValueHandling.Ignore)]
        public EntryDisplay Display { get; set; }

        /// <summary>
        /// Required. Name of the entry  (e.g. "bicycle"). The entry in this field
        /// must be included in repeated synonyms field to be recogonized as a valid
        /// type value.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Required. List of synonyms for the entry (e.g. "bike", "cycle").
        /// </summary>
        [JsonProperty("synonyms", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Synonyms { get; set; }
    }

    /// <summary>
    /// Optional. The item display's information.
    /// </summary>
    public partial class EntryDisplay
    {
        /// <summary>
        /// Optional. Body text of the card.
        /// </summary>
        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// Optional. Footer text for the browsing collection item, displayed below
        /// the description. Single line of text, truncated with an ellipsis.
        /// </summary>
        [JsonProperty("footer", NullValueHandling = NullValueHandling.Ignore)]
        public string Footer { get; set; }

        /// <summary>
        /// Optional. The image to display.
        /// </summary>
        [JsonProperty("image", NullValueHandling = NullValueHandling.Ignore)]
        public Image Image { get; set; }

        /// <summary>
        /// URL of document associated with browsing carousel item.
        /// Required for browsing carousel.
        /// </summary>
        [JsonProperty("openUrl", NullValueHandling = NullValueHandling.Ignore)]
        public OpenUrl OpenUrl { get; set; }

        /// <summary>
        /// Required. Title of the item. When tapped, this text will be
        /// posted back to the conversation verbatim as if the user had typed it.
        /// Each title must be unique among the set of collection items.
        /// </summary>
        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public string Title { get; set; }
    }

    /// <summary>
    /// Optional. The image to display.
    ///
    /// An image displayed in the card.
    ///
    /// A hero image for the card. The height is fixed to 192dp.
    /// Optional.
    ///
    /// An image.
    ///
    /// A small image icon displayed on the right from the title.
    /// It's resized to 36x36 dp.
    ///
    /// A large image, such as the cover of the album, etc.
    ///
    /// Image associated with the table. Optional.
    /// </summary>
    public partial class Image
    {
        /// <summary>
        /// A text description of the image to be used for accessibility, e.g. screen
        /// readers.
        /// Required.
        /// </summary>
        [JsonProperty("alt", NullValueHandling = NullValueHandling.Ignore)]
        public string Alt { get; set; }

        /// <summary>
        /// The height of the image in pixels.
        /// Optional.
        /// </summary>
        [JsonProperty("height", NullValueHandling = NullValueHandling.Ignore)]
        public long? Height { get; set; }

        /// <summary>
        /// The source url of the image. Images can be JPG, PNG and GIF (animated and
        /// non-animated). For example,`https://www.agentx.com/logo.png`. Required.
        /// </summary>
        [JsonProperty("url", NullValueHandling = NullValueHandling.Ignore)]
        public string Url { get; set; }

        /// <summary>
        /// The width of the image in pixels.
        /// Optional.
        /// </summary>
        [JsonProperty("width", NullValueHandling = NullValueHandling.Ignore)]
        public long? Width { get; set; }
    }

    /// <summary>
    /// URL of document associated with browsing carousel item.
    /// Required for browsing carousel.
    ///
    /// What happens when a user opens the link
    /// </summary>
    public partial class OpenUrl
    {
        /// <summary>
        /// Indicates a hint for the url type.
        /// </summary>
        [JsonProperty("hint", NullValueHandling = NullValueHandling.Ignore)]
        public Hint? Hint { get; set; }

        /// <summary>
        /// The url field which could be any of:
        /// - http/https urls for opening an App-linked App or a webpage
        /// </summary>
        [JsonProperty("url", NullValueHandling = NullValueHandling.Ignore)]
        public string Url { get; set; }
    }

    /// <summary>
    /// Required. User who initiated the conversation.
    ///
    /// Represents the user making a request to the Action.
    ///
    /// Optional. Use to specify user parameters to send back.
    /// </summary>
    public partial class User
    {
        /// <summary>
        /// Whether the user account is linked to the app.
        /// </summary>
        [JsonProperty("accountLinkingStatus", NullValueHandling = NullValueHandling.Ignore)]
        public AccountLinkingStatus? AccountLinkingStatus { get; set; }

        /// <summary>
        /// The engagement of the current user including any subscriptions to intents.
        /// </summary>
        [JsonProperty("engagement", NullValueHandling = NullValueHandling.Ignore)]
        public Engagement Engagement { get; set; }

        /// <summary>
        /// The timestamp of the last interaction with this user.
        /// This field will be omitted if the user has not interacted with the agent
        /// before.
        /// </summary>
        [JsonProperty("lastSeenTime", NullValueHandling = NullValueHandling.Ignore)]
        public string LastSeenTime { get; set; }

        /// <summary>
        /// Primary locale setting of the user making the request. Follows IETF BCP-47
        /// language code http://www.rfc-editor.org/rfc/bcp/bcp47.txt However, the
        /// script subtag is not included.
        /// </summary>
        [JsonProperty("locale", NullValueHandling = NullValueHandling.Ignore)]
        public string Locale { get; set; }

        /// <summary>
        /// User's entitlements related to the Android package associated with the
        /// current action.
        /// </summary>
        [JsonProperty("packageEntitlements", NullValueHandling = NullValueHandling.Ignore)]
        public List<PackageEntitlements> PackageEntitlements { get; set; }

        /// <summary>
        /// Optional. List of all parameters associated with the current user.
        /// </summary>
        [JsonProperty("params", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, dynamic> Params { get; set; }

        /// <summary>
        /// Indicates the verification status of the user.
        /// </summary>
        [JsonProperty("verificationStatus", NullValueHandling = NullValueHandling.Ignore)]
        public VerificationStatus? VerificationStatus { get; set; }
    }

    /// <summary>
    /// The engagement of the current user including any subscriptions to intents.
    ///
    /// Provides additional read-only information about what engagement mechanisms
    /// the current user has registered for. For example, it can be useful to know
    /// what intents the user is already subscribed to in order to avoid asking them
    /// to subscribe to the same intent again. i.e. This information can be used to
    /// conditionally route to a scene to set up DailyUpdates or PushNotifications
    /// only if the user has not subscribed already.
    /// </summary>
    public partial class Engagement
    {
        /// <summary>
        /// Contains a list of intents which the user has enabled daily update
        /// for.
        /// </summary>
        [JsonProperty("dailyUpdateIntents", NullValueHandling = NullValueHandling.Ignore)]
        public List<IntentSubscription> DailyUpdateIntents { get; set; }

        /// <summary>
        /// Contains a list of intents which the user has enabled push notification
        /// for.
        /// </summary>
        [JsonProperty("pushNotificationIntents", NullValueHandling = NullValueHandling.Ignore)]
        public List<IntentSubscription> PushNotificationIntents { get; set; }
    }

    /// <summary>
    /// Describes an existing IntentSubscription.
    /// </summary>
    public partial class IntentSubscription
    {
        /// <summary>
        /// A short description of the subscription. It is used as the notification's
        /// label and when Assistant is requesting permission from the user.
        /// </summary>
        [JsonProperty("contentTitle", NullValueHandling = NullValueHandling.Ignore)]
        public string ContentTitle { get; set; }

        /// <summary>
        /// Name of the intent which is subscribed to.
        /// </summary>
        [JsonProperty("intent", NullValueHandling = NullValueHandling.Ignore)]
        public string Intent { get; set; }
    }

    /// <summary>
    /// A List of user's entitlements related to a package name.
    /// </summary>
    public partial class PackageEntitlements
    {
        /// <summary>
        /// The user's entitlements for the given package.
        /// </summary>
        [JsonProperty("entitlements", NullValueHandling = NullValueHandling.Ignore)]
        public List<Entitlement> Entitlements { get; set; }

        /// <summary>
        /// The Android package name specified in the action package.
        /// </summary>
        [JsonProperty("packageName", NullValueHandling = NullValueHandling.Ignore)]
        public string PackageName { get; set; }
    }

    /// <summary>
    /// Defines a user's digital entitlement.
    /// </summary>
    public partial class Entitlement
    {
        /// <summary>
        /// Only present for in-app purchase and in-app subs.
        /// </summary>
        [JsonProperty("inAppDetails", NullValueHandling = NullValueHandling.Ignore)]
        public SignedData InAppDetails { get; set; }

        /// <summary>
        /// Product sku. Package name for paid app, suffix of Finsky docid for
        /// in-app purchase and in-app subscription.
        /// Match getSku() in Play InApp Billing API.
        /// </summary>
        [JsonProperty("sku", NullValueHandling = NullValueHandling.Ignore)]
        public string Sku { get; set; }

        /// <summary>
        /// The type of SKU.
        /// </summary>
        [JsonProperty("skuType", NullValueHandling = NullValueHandling.Ignore)]
        public SkuType? SkuType { get; set; }
    }

    /// <summary>
    /// Only present for in-app purchase and in-app subs.
    /// </summary>
    public partial class SignedData
    {
        /// <summary>
        /// Matches IN_APP_DATA_SIGNATURE from getPurchases() method in Play InApp
        /// Billing API.
        /// </summary>
        [JsonProperty("inAppDataSignature", NullValueHandling = NullValueHandling.Ignore)]
        public string InAppDataSignature { get; set; }

        /// <summary>
        /// Contains all inapp purchase data in JSON format.
        /// See details in table 6 of
        /// https://developer.android.com/google/play/billing/billing_reference.html.
        /// </summary>
        [JsonProperty("inAppPurchaseData", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, dynamic> InAppPurchaseData { get; set; }
    }

    /// <summary>
    /// Represents a response sent from a developer's fulfillment to Actions on
    /// Google.
    /// </summary>
    public partial class HandlerResponse
    {
        /// <summary>
        /// Optional. Use to move between Assistant devices the user has access to.
        /// </summary>
        [JsonProperty("device", NullValueHandling = NullValueHandling.Ignore)]
        public Device Device { get; set; }

        /// <summary>
        /// Optional. Describes the expectations for the next dialog turn.
        /// </summary>
        [JsonProperty("expected", NullValueHandling = NullValueHandling.Ignore)]
        public Expected Expected { get; set; }

        /// <summary>
        /// Optional. Used to specify parameters related to the HomeGraph structure
        /// that the target device belongs to. See
        /// https://developers.google.com/actions/smarthome/concepts/homegraph.
        /// </summary>
        [JsonProperty("home", NullValueHandling = NullValueHandling.Ignore)]
        public Home Home { get; set; }

        /// <summary>
        /// Optional. Represents the prompts to be sent to the user, these prompts
        /// will be appended to previously added messages unless explicitly
        /// overwritten.
        /// </summary>
        [JsonProperty("prompt", NullValueHandling = NullValueHandling.Ignore)]
        public Prompt Prompt { get; set; }

        /// <summary>
        /// Optional. Represents the current and next scene. If `Scene.next` is set
        /// the runtime will immediately transition to the specified scene.
        /// </summary>
        [JsonProperty("scene", NullValueHandling = NullValueHandling.Ignore)]
        public Scene Scene { get; set; }

        /// <summary>
        /// Optional. Describes data for the current session, session
        /// parameters can be created, updated, or removed by the fulfillment.
        /// </summary>
        [JsonProperty("session", NullValueHandling = NullValueHandling.Ignore)]
        public Session Session { get; set; }

        /// <summary>
        /// Optional. Use to specify user parameters to send back.
        /// </summary>
        [JsonProperty("user", NullValueHandling = NullValueHandling.Ignore)]
        public User User { get; set; }
    }

    /// <summary>
    /// Optional. Describes the expectations for the next dialog turn.
    ///
    /// Describes the expectations for the next dialog turn.
    /// </summary>
    public partial class Expected
    {
        /// <summary>
        /// List of phrases the Action expects from the user's utterance for speech
        /// biasing. Up to 1000 phrases are allowed.
        /// Note: This field has the same meaning as ExpectedInput.speech_biasing_hints
        /// in the v2 API.
        /// </summary>
        [JsonProperty("speech", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Speech { get; set; }
    }

    /// <summary>
    /// Optional. Represents the prompts to be sent to the user, these prompts
    /// will be appended to previously added messages unless explicitly
    /// overwritten.
    ///
    /// Represent a response to a user.
    /// </summary>
    public partial class Prompt
    {
        /// <summary>
        /// Optional. Represents a Interactive Canvas response to be sent to the user.
        /// </summary>
        [JsonProperty("canvas", NullValueHandling = NullValueHandling.Ignore)]
        public Canvas Canvas { get; set; }

        /// <summary>
        /// Optional. A content like a card, list or media to display to the user.
        /// </summary>
        [JsonProperty("content", NullValueHandling = NullValueHandling.Ignore)]
        public Content Content { get; set; }

        /// <summary>
        /// Optional. The first voice and text-only response.
        /// </summary>
        [JsonProperty("firstSimple", NullValueHandling = NullValueHandling.Ignore)]
        public Simple FirstSimple { get; set; }

        /// <summary>
        /// Optional. The last voice and text-only response.
        /// </summary>
        [JsonProperty("lastSimple", NullValueHandling = NullValueHandling.Ignore)]
        public Simple LastSimple { get; set; }

        /// <summary>
        /// Optional. An additional suggestion chip that can link out to the associated app
        /// or site.
        /// The chip will be rendered with the title "Open <name>". Max 20 chars.
        /// </summary>
        [JsonProperty("link", NullValueHandling = NullValueHandling.Ignore)]
        public Link Link { get; set; }

        /// <summary>
        /// Optional
        /// Action responds with an OrderUpdate after receiving the order during the
        /// transactions flow. On receipt of this, Google records this update to the
        /// order, and if successful, displays a receipt card along with the TTS sent
        /// on display devices.
        /// </summary>
        [JsonProperty("orderUpdate", NullValueHandling = NullValueHandling.Ignore)]
        public OrderUpdate OrderUpdate { get; set; }

        /// <summary>
        /// Optional. Mode for how this messages should be merged with previously
        /// defined messages.
        /// "true" clears all previously defined messages (first and last
        /// simple, content, suggestions link and canvas) and adds messages defined in
        /// this prompt.
        /// "false" adds messages defined in this prompt to messages defined in
        /// previous responses. Leaving this field to "false" also enables
        /// appending to some fields inside Simple prompts, the Suggestions prompt,
        /// and the Canvas prompt (part of the Content prompt). The Content and Link
        /// messages are always overwritten if defined in the prompt. Default
        /// value is "false".
        /// </summary>
        [JsonProperty("override", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Override { get; set; }

        /// <summary>
        /// Optional. Suggestions to be displayed to the user which will always appear
        /// at the end of the response.
        /// If the "override" field in the containing prompt is "false", the titles
        /// defined in this field will be added to titles defined in any previously
        /// defined suggestions prompts and duplicate values will be removed.
        /// </summary>
        [JsonProperty("suggestions", NullValueHandling = NullValueHandling.Ignore)]
        public List<Suggestion> Suggestions { get; set; }
    }

    /// <summary>
    /// Optional. Represents a Interactive Canvas response to be sent to the user.
    ///
    /// Represents an Interactive Canvas response to be sent to the user.
    /// This can be used in conjunction with the "first_simple" field in the
    /// containing prompt to speak to the user in addition to displaying a
    /// interactive canvas response. The maximum size of the response is 50k bytes.
    /// </summary>
    public partial class Canvas
    {
        /// <summary>
        /// Optional. JSON data to be passed through to the immersive experience
        /// web page as an event.
        /// If the "override" field in the containing prompt is "false" data values
        /// defined in this Canvas prompt will be added after data values defined in
        /// previous Canvas prompts.
        /// </summary>
        [JsonProperty("data", NullValueHandling = NullValueHandling.Ignore)]
        public List<dynamic> Data { get; set; }

        /// <summary>
        /// Optional. Default value: false.
        /// </summary>
        [JsonProperty("suppressMic", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SuppressMic { get; set; }

        /// <summary>
        /// URL of the interactive canvas web app to load. If not set, the url from
        /// current active canvas will be reused.
        /// </summary>
        [JsonProperty("url", NullValueHandling = NullValueHandling.Ignore)]
        public string Url { get; set; }
    }

    /// <summary>
    /// Optional. A content like a card, list or media to display to the user.
    /// </summary>
    public partial class Content
    {
        /// <summary>
        /// A basic card.
        /// </summary>
        [JsonProperty("card", NullValueHandling = NullValueHandling.Ignore)]
        public Card Card { get; set; }

        /// <summary>
        /// A card presenting a collection of options to select from.
        /// </summary>
        [JsonProperty("collection", NullValueHandling = NullValueHandling.Ignore)]
        public Collection Collection { get; set; }

        /// <summary>
        /// An image.
        /// </summary>
        [JsonProperty("image", NullValueHandling = NullValueHandling.Ignore)]
        public Image Image { get; set; }

        /// <summary>
        /// A card presenting a list of options to select from.
        /// </summary>
        [JsonProperty("list", NullValueHandling = NullValueHandling.Ignore)]
        public List List { get; set; }

        /// <summary>
        /// Response indicating a set of media to be played.
        /// </summary>
        [JsonProperty("media", NullValueHandling = NullValueHandling.Ignore)]
        public Media Media { get; set; }

        /// <summary>
        /// Table card.
        /// </summary>
        [JsonProperty("table", NullValueHandling = NullValueHandling.Ignore)]
        public Table Table { get; set; }
    }

    /// <summary>
    /// A basic card.
    ///
    /// A basic card for displaying some information, e.g. an image and/or text.
    /// </summary>
    public partial class Card
    {
        /// <summary>
        /// Button.
        /// Optional.
        /// </summary>
        [JsonProperty("button", NullValueHandling = NullValueHandling.Ignore)]
        public Link Button { get; set; }

        /// <summary>
        /// A hero image for the card. The height is fixed to 192dp.
        /// Optional.
        /// </summary>
        [JsonProperty("image", NullValueHandling = NullValueHandling.Ignore)]
        public Image Image { get; set; }

        /// <summary>
        /// How the image background will be filled. Optional.
        /// </summary>
        [JsonProperty("imageFill", NullValueHandling = NullValueHandling.Ignore)]
        public ImageFill? ImageFill { get; set; }

        /// <summary>
        /// Optional.
        /// </summary>
        [JsonProperty("subtitle", NullValueHandling = NullValueHandling.Ignore)]
        public string Subtitle { get; set; }

        /// <summary>
        /// Body text of the card.
        /// Supports a limited set of markdown syntax for formatting.
        /// Required, unless image is present.
        /// </summary>
        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public string Text { get; set; }

        /// <summary>
        /// Overall title of the card.
        /// Optional.
        /// </summary>
        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public string Title { get; set; }
    }

    /// <summary>
    /// Button.
    /// Optional.
    ///
    /// Button.
    ///
    /// Optional. An additional suggestion chip that can link out to the associated app
    /// or site.
    /// The chip will be rendered with the title "Open <name>". Max 20 chars.
    /// </summary>
    public partial class Link
    {
        /// <summary>
        /// Name of the link
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// What happens when a user opens the link
        /// </summary>
        [JsonProperty("open", NullValueHandling = NullValueHandling.Ignore)]
        public OpenUrl Open { get; set; }
    }

    /// <summary>
    /// A card presenting a collection of options to select from.
    ///
    /// A card for presenting a collection of options to select from.
    /// </summary>
    public partial class Collection
    {
        /// <summary>
        /// How the image backgrounds of collection items will be filled. Optional.
        /// </summary>
        [JsonProperty("imageFill", NullValueHandling = NullValueHandling.Ignore)]
        public ImageFill? ImageFill { get; set; }

        /// <summary>
        /// min: 2 max: 10
        /// </summary>
        [JsonProperty("items", NullValueHandling = NullValueHandling.Ignore)]
        public List<CollectionItem> Items { get; set; }

        /// <summary>
        /// Subtitle of the collection. Optional.
        /// </summary>
        [JsonProperty("subtitle", NullValueHandling = NullValueHandling.Ignore)]
        public string Subtitle { get; set; }

        /// <summary>
        /// Title of the collection. Optional.
        /// </summary>
        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public string Title { get; set; }
    }

    /// <summary>
    /// An item in the collection
    /// </summary>
    public partial class CollectionItem
    {
        /// <summary>
        /// Required. The NLU key that matches the entry key name in the associated
        /// Type.
        /// </summary>
        [JsonProperty("key", NullValueHandling = NullValueHandling.Ignore)]
        public string Key { get; set; }
    }

    /// <summary>
    /// A card presenting a list of options to select from.
    ///
    /// A card for presenting a list of options to select from.
    /// </summary>
    public partial class List
    {
        /// <summary>
        /// min: 2 max: 30
        /// </summary>
        [JsonProperty("items", NullValueHandling = NullValueHandling.Ignore)]
        public List<ListItem> Items { get; set; }

        /// <summary>
        /// Subtitle of the list. Optional.
        /// </summary>
        [JsonProperty("subtitle", NullValueHandling = NullValueHandling.Ignore)]
        public string Subtitle { get; set; }

        /// <summary>
        /// Title of the list. Optional.
        /// </summary>
        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public string Title { get; set; }
    }

    /// <summary>
    /// An item in the list
    /// </summary>
    public partial class ListItem
    {
        /// <summary>
        /// Required. The NLU key that matches the entry key name in the associated
        /// Type.
        /// </summary>
        [JsonProperty("key", NullValueHandling = NullValueHandling.Ignore)]
        public string Key { get; set; }
    }

    /// <summary>
    /// Response indicating a set of media to be played.
    ///
    /// Represents one media object.
    /// Contains information about the media, such as name, description, url, etc.
    /// </summary>
    public partial class Media
    {
        /// <summary>
        /// List of Media Objects
        /// </summary>
        [JsonProperty("mediaObjects", NullValueHandling = NullValueHandling.Ignore)]
        public List<MediaObject> MediaObjects { get; set; }

        [JsonProperty("mediaType", NullValueHandling = NullValueHandling.Ignore)]
        public MediaType? MediaType { get; set; }

        /// <summary>
        /// Optional media control types this media response session can support.
        /// If set, request will be made to 3p when a certain media event happens.
        /// If not set, 3p must still handle two default control type, FINISHED and
        /// FAILED.
        /// </summary>
        [JsonProperty("optionalMediaControls", NullValueHandling = NullValueHandling.Ignore)]
        public List<OptionalMediaControl> OptionalMediaControls { get; set; }

        /// <summary>
        /// Start offset of the first media object.
        /// </summary>
        [JsonProperty("startOffset", NullValueHandling = NullValueHandling.Ignore)]
        public string StartOffset { get; set; }
    }

    /// <summary>
    /// Represents a single media object
    /// </summary>
    public partial class MediaObject
    {
        /// <summary>
        /// Description of this media object.
        /// </summary>
        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// Image to show with the media card.
        /// </summary>
        [JsonProperty("image", NullValueHandling = NullValueHandling.Ignore)]
        public MediaImage Image { get; set; }

        /// <summary>
        /// Name of this media object.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The url pointing to the media content.
        /// </summary>
        [JsonProperty("url", NullValueHandling = NullValueHandling.Ignore)]
        public string Url { get; set; }
    }

    /// <summary>
    /// Image to show with the media card.
    /// </summary>
    public partial class MediaImage
    {
        /// <summary>
        /// A small image icon displayed on the right from the title.
        /// It's resized to 36x36 dp.
        /// </summary>
        [JsonProperty("icon", NullValueHandling = NullValueHandling.Ignore)]
        public Image Icon { get; set; }

        /// <summary>
        /// A large image, such as the cover of the album, etc.
        /// </summary>
        [JsonProperty("large", NullValueHandling = NullValueHandling.Ignore)]
        public Image Large { get; set; }
    }

    /// <summary>
    /// Table card.
    ///
    /// A table card for displaying a table of text.
    /// </summary>
    public partial class Table
    {
        /// <summary>
        /// Button.
        /// </summary>
        [JsonProperty("button", NullValueHandling = NullValueHandling.Ignore)]
        public Link Button { get; set; }

        /// <summary>
        /// Headers and alignment of columns.
        /// </summary>
        [JsonProperty("columns", NullValueHandling = NullValueHandling.Ignore)]
        public List<TableColumn> Columns { get; set; }

        /// <summary>
        /// Image associated with the table. Optional.
        /// </summary>
        [JsonProperty("image", NullValueHandling = NullValueHandling.Ignore)]
        public Image Image { get; set; }

        /// <summary>
        /// Row data of the table. The first 3 rows are guaranteed to be shown but
        /// others might be cut on certain surfaces. Please test with the simulator to
        /// see which rows will be shown for a given surface. On surfaces that support
        /// the WEB_BROWSER capability, you can point the user to
        /// a web page with more data.
        /// </summary>
        [JsonProperty("rows", NullValueHandling = NullValueHandling.Ignore)]
        public List<TableRow> Rows { get; set; }

        /// <summary>
        /// Subtitle for the table. Optional.
        /// </summary>
        [JsonProperty("subtitle", NullValueHandling = NullValueHandling.Ignore)]
        public string Subtitle { get; set; }

        /// <summary>
        /// Overall title of the table. Optional but must be set if subtitle is set.
        /// </summary>
        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public string Title { get; set; }
    }

    public partial class TableColumn
    {
        /// <summary>
        /// Horizontal alignment of content w.r.t column. If unspecified, content
        /// will be aligned to the leading edge.
        /// </summary>
        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public Align? Align { get; set; }

        /// <summary>
        /// Header text for the column.
        /// </summary>
        [JsonProperty("header", NullValueHandling = NullValueHandling.Ignore)]
        public string Header { get; set; }
    }

    /// <summary>
    /// Describes a row in the table.
    /// </summary>
    public partial class TableRow
    {
        /// <summary>
        /// Cells in this row. The first 3 cells are guaranteed to be shown but
        /// others might be cut on certain surfaces. Please test with the simulator
        /// to see which cells will be shown for a given surface.
        /// </summary>
        [JsonProperty("cells", NullValueHandling = NullValueHandling.Ignore)]
        public List<TableCell> Cells { get; set; }

        /// <summary>
        /// Indicates whether there should be a divider after each row.
        /// </summary>
        [JsonProperty("divider", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Divider { get; set; }
    }

    /// <summary>
    /// Describes a cell in a row.
    /// </summary>
    public partial class TableCell
    {
        /// <summary>
        /// Text content of the cell.
        /// </summary>
        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public string Text { get; set; }
    }

    /// <summary>
    /// Optional. The first voice and text-only response.
    ///
    /// Represents a simple prompt to be send to a user.
    ///
    /// Optional. The last voice and text-only response.
    /// </summary>
    public partial class Simple
    {
        /// <summary>
        /// Optional. Represents the speech to be spoken to the user. Can be SSML or
        /// text to speech.
        /// If the "override" field in the containing prompt is "true", the speech
        /// defined in this field replaces the previous Simple prompt's speech.
        /// </summary>
        [JsonProperty("speech", NullValueHandling = NullValueHandling.Ignore)]
        public string Speech { get; set; }

        /// <summary>
        /// Optional text to display in the chat bubble. If not given, a display
        /// rendering of the speech field above will be used. Limited to 640
        /// chars.
        /// If the "override" field in the containing prompt is "true", the text
        /// defined in this field replaces to the previous Simple prompt's text.
        /// </summary>
        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public string Text { get; set; }
    }

    /// <summary>
    /// Optional
    /// Action responds with an OrderUpdate after receiving the order during the
    /// transactions flow. On receipt of this, Google records this update to the
    /// order, and if successful, displays a receipt card along with the TTS sent
    /// on display devices.
    ///
    /// Update to an order.
    /// </summary>
    public partial class OrderUpdate
    {
        [JsonProperty("order", NullValueHandling = NullValueHandling.Ignore)]
        public Order Order { get; set; }

        /// <summary>
        /// Reason for the change/update.
        /// </summary>
        [JsonProperty("reason", NullValueHandling = NullValueHandling.Ignore)]
        public string Reason { get; set; }

        /// <summary>
        /// Deprecated: Use OrderUpdate.update_mask instead.
        /// If type = SNAPSHOT, OrderUpdate.order should be the entire order.
        /// If type = ORDER_STATUS, this is the order level status change. Only
        /// order.last_update_time and this vertical status are picked up.
        /// Note: type.ORDER_STATUS only supports PurcahaseOrderExtension status
        /// updates and there is no plan to extend this support. Instead, we recommend
        /// using update_mask as it is more generic, extensible and can be used for all
        /// verticals.
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public OrderUpdateType? Type { get; set; }

        /// <summary>
        /// Note: There are following consideration/recommendations for following
        /// special fields:
        /// 1. order.last_update_time will always be updated as part of the update
        /// request.
        /// 2. order.create_time, order.google_order_id and order.merchant_order_id
        /// will be ignored if provided as part of the update_mask.
        /// </summary>
        [JsonProperty("updateMask", NullValueHandling = NullValueHandling.Ignore)]
        public string UpdateMask { get; set; }

        /// <summary>
        /// If specified, displays a notification to the user with the specified
        /// title and text. Specifying a notification is a suggestion to
        /// notify and is not guaranteed to result in a notification.
        /// </summary>
        [JsonProperty("userNotification", NullValueHandling = NullValueHandling.Ignore)]
        public UserNotification UserNotification { get; set; }
    }

    /// <summary>
    /// Order entity.
    /// Note:
    /// 1. All strings at all levels must be less than 1000 chars unless otherwise
    /// specified.
    /// 2. All repeated fields at all levels must be less than 50 in count unless
    /// otherwise specified.
    /// 3. All timestamps at all levels, if specified, must be valid timestamps.
    /// </summary>
    public partial class Order
    {
        /// <summary>
        /// Info about the buyer.
        /// </summary>
        [JsonProperty("buyerInfo", NullValueHandling = NullValueHandling.Ignore)]
        public UserInfo BuyerInfo { get; set; }

        /// <summary>
        /// Required: Order contents which is a group of line items.
        /// </summary>
        [JsonProperty("contents", NullValueHandling = NullValueHandling.Ignore)]
        public Contents Contents { get; set; }

        /// <summary>
        /// Required: Date and time the order was created.
        /// </summary>
        [JsonProperty("createTime", NullValueHandling = NullValueHandling.Ignore)]
        public string CreateTime { get; set; }

        /// <summary>
        /// Disclosures associated with this order.
        /// </summary>
        [JsonProperty("disclosures", NullValueHandling = NullValueHandling.Ignore)]
        public List<Disclosure> Disclosures { get; set; }

        /// <summary>
        /// Follow up actions at order level.
        /// </summary>
        [JsonProperty("followUpActions", NullValueHandling = NullValueHandling.Ignore)]
        public List<FollowUpActionElement> FollowUpActions { get; set; }

        /// <summary>
        /// Google assigned order id.
        /// </summary>
        [JsonProperty("googleOrderId", NullValueHandling = NullValueHandling.Ignore)]
        public string GoogleOrderId { get; set; }

        /// <summary>
        /// Image associated with the order.
        /// </summary>
        [JsonProperty("image", NullValueHandling = NullValueHandling.Ignore)]
        public V2UiElementsImage Image { get; set; }

        /// <summary>
        /// Date and time the order was last updated.
        /// Required for OrderUpdate.
        /// </summary>
        [JsonProperty("lastUpdateTime", NullValueHandling = NullValueHandling.Ignore)]
        public string LastUpdateTime { get; set; }

        /// <summary>
        /// Required: Merchant assigned internal order id. This id must be unique, and
        /// is required for subsequent order update operations. This id may be set to
        /// the provided google_order_id, or any other unique value. Note that the id
        /// presented to users is the user_visible_order_id, which may be a different,
        /// more user-friendly value.
        /// Max allowed length is 128 chars.
        /// </summary>
        [JsonProperty("merchantOrderId", NullValueHandling = NullValueHandling.Ignore)]
        public string MerchantOrderId { get; set; }

        /// <summary>
        /// Notes attached to an order.
        /// </summary>
        [JsonProperty("note", NullValueHandling = NullValueHandling.Ignore)]
        public string Note { get; set; }

        /// <summary>
        /// Payment related data for the order.
        /// </summary>
        [JsonProperty("paymentData", NullValueHandling = NullValueHandling.Ignore)]
        public PaymentData PaymentData { get; set; }

        /// <summary>
        /// Price, discounts, taxes and so on.
        /// </summary>
        [JsonProperty("priceAttributes", NullValueHandling = NullValueHandling.Ignore)]
        public List<PriceAttribute> PriceAttributes { get; set; }

        /// <summary>
        /// All promotions that are associated with this order.
        /// </summary>
        [JsonProperty("promotions", NullValueHandling = NullValueHandling.Ignore)]
        public List<Promotion> Promotions { get; set; }

        /// <summary>
        /// Purchase order
        /// </summary>
        [JsonProperty("purchase", NullValueHandling = NullValueHandling.Ignore)]
        public PurchasePurchaseOrderExtension Purchase { get; set; }

        /// <summary>
        /// A link to the terms of service that apply to order/proposed order.
        /// </summary>
        [JsonProperty("termsOfServiceUrl", NullValueHandling = NullValueHandling.Ignore)]
        public string TermsOfServiceUrl { get; set; }

        /// <summary>
        /// Ticket order
        /// </summary>
        [JsonProperty("ticket", NullValueHandling = NullValueHandling.Ignore)]
        public TicketTicketOrderExtension Ticket { get; set; }

        /// <summary>
        /// Merchant that facilitated the checkout. This could be different from
        /// a line item level provider. Example: Expedia Order with line item from ANA.
        /// </summary>
        [JsonProperty("transactionMerchant", NullValueHandling = NullValueHandling.Ignore)]
        public Merchant TransactionMerchant { get; set; }

        /// <summary>
        /// The user facing id referencing to current order. This id should be
        /// consistent with the id displayed for this order in other contexts,
        /// including websites, apps and email.
        /// </summary>
        [JsonProperty("userVisibleOrderId", NullValueHandling = NullValueHandling.Ignore)]
        public string UserVisibleOrderId { get; set; }

        /// <summary>
        /// Deprecated: Use OrderExtensions status instead.
        /// User visible label for the state of this order.
        /// </summary>
        [JsonProperty("userVisibleStateLabel", NullValueHandling = NullValueHandling.Ignore)]
        public string UserVisibleStateLabel { get; set; }

        /// <summary>
        /// Deprecated: Use verticals instead.
        /// These properties will apply to all line items, unless overridden in
        /// some line item. This vertical must match the line item level vertical type.
        /// Possible values:
        /// google.actions.orders.v3.verticals.purchase.PurchaseOrderExtension
        /// google.actions.orders.v3.verticals.ticket.TicketOrderExtension
        /// </summary>
        [JsonProperty("vertical", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, dynamic> Vertical { get; set; }
    }

    /// <summary>
    /// Info about the buyer.
    ///
    /// Information about user. This is used to represent information of the user
    /// associated with an order.
    ///
    /// User contact for this fulfillment.
    /// </summary>
    public partial class UserInfo
    {
        /// <summary>
        /// Display name of the user, might be different from first or last name.
        /// </summary>
        [JsonProperty("displayName", NullValueHandling = NullValueHandling.Ignore)]
        public string DisplayName { get; set; }

        /// <summary>
        /// User email, Eg: janedoe@gmail.com.
        /// </summary>
        [JsonProperty("email", NullValueHandling = NullValueHandling.Ignore)]
        public string Email { get; set; }

        /// <summary>
        /// First name of the user.
        /// </summary>
        [JsonProperty("firstName", NullValueHandling = NullValueHandling.Ignore)]
        public string FirstName { get; set; }

        /// <summary>
        /// Last name of the user.
        /// </summary>
        [JsonProperty("lastName", NullValueHandling = NullValueHandling.Ignore)]
        public string LastName { get; set; }

        /// <summary>
        /// Phone numbers of the user.
        /// </summary>
        [JsonProperty("phoneNumbers", NullValueHandling = NullValueHandling.Ignore)]
        public List<PhoneNumber> PhoneNumbers { get; set; }
    }

    /// <summary>
    /// Standard phone number representation.
    /// </summary>
    public partial class PhoneNumber
    {
        /// <summary>
        /// Phone number in E.164 format, as defined in International
        /// Telecommunication Union (ITU) Recommendation E.164.
        /// wiki link: https://en.wikipedia.org/wiki/E.164
        /// </summary>
        [JsonProperty("e164PhoneNumber", NullValueHandling = NullValueHandling.Ignore)]
        public string E164PhoneNumber { get; set; }

        /// <summary>
        /// Extension is not standardized in ITU recommendations, except for being
        /// defined as a series of numbers with a maximum length of 40 digits. It is
        /// defined as a string here to accommodate for the possible use of a leading
        /// zero in the extension (organizations have complete freedom to do so, as
        /// there is no standard defined). Other than digits, some other dialling
        /// characters such as "," (indicating a wait) may be stored here.
        /// For example, in xxx-xxx-xxxx ext. 123, "123" is the extension.
        /// </summary>
        [JsonProperty("extension", NullValueHandling = NullValueHandling.Ignore)]
        public string Extension { get; set; }

        /// <summary>
        /// The carrier selection code that is preferred when calling this phone number
        /// domestically. This also includes codes that need to be dialed in some
        /// countries when calling from landlines to mobiles or vice versa. For
        /// example, in Columbia, a "3" needs to be dialed before the phone number
        /// itself when calling from a mobile phone to a domestic landline phone and
        /// vice versa. https://en.wikipedia.org/wiki/Telephone_numbers_in_Colombia
        /// https://en.wikipedia.org/wiki/Brazilian_Carrier_Selection_Code
        ///
        /// Note this is the "preferred" code, which means other codes may work as
        /// well.
        /// </summary>
        [JsonProperty("preferredDomesticCarrierCode", NullValueHandling = NullValueHandling.Ignore)]
        public string PreferredDomesticCarrierCode { get; set; }
    }

    /// <summary>
    /// Required: Order contents which is a group of line items.
    ///
    /// Wrapper for line items.
    /// </summary>
    public partial class Contents
    {
        /// <summary>
        /// List of order line items.
        /// At least 1 line_item is required and at-most 50 is allowed.
        /// All line items must belong to same vertical.
        /// </summary>
        [JsonProperty("lineItems", NullValueHandling = NullValueHandling.Ignore)]
        public List<LineItem> LineItems { get; set; }
    }

    /// <summary>
    /// One line item contains one vertical. An order or cart can have multiple
    /// line items of same vertical. Sub-line items/add-ons etc should be defined in
    /// vertical protos depending on their use cases.
    /// Note:
    /// 1. All strings at all levels must be less than 1000 chars unless otherwise
    /// specified.
    /// 2. All repeated fields at all levels must be less than 50 in count unless
    /// otherwise specified.
    /// 3. All timestamps at all levels, if specified, must be valid timestamps.
    /// </summary>
    public partial class LineItem
    {
        /// <summary>
        /// Line item description.
        /// </summary>
        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// Disclosures associated with this line item.
        /// </summary>
        [JsonProperty("disclosures", NullValueHandling = NullValueHandling.Ignore)]
        public List<Disclosure> Disclosures { get; set; }

        /// <summary>
        /// Follow up actions at line item.
        /// </summary>
        [JsonProperty("followUpActions", NullValueHandling = NullValueHandling.Ignore)]
        public List<FollowUpActionElement> FollowUpActions { get; set; }

        /// <summary>
        /// Required: Merchant assigned identifier for line item.
        /// Used for identifying existing line item in applying partial updates.
        /// Max allowed length is 64 chars.
        /// </summary>
        [JsonProperty("id", NullValueHandling = NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// Small image associated with this item, if any.
        /// </summary>
        [JsonProperty("image", NullValueHandling = NullValueHandling.Ignore)]
        public V2UiElementsImage Image { get; set; }

        /// <summary>
        /// Name of line item as displayed on the receipt.
        /// Max allowed length is 100 chars.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Additional notes applicable to this particular line item, for example
        /// cancellation policy.
        /// </summary>
        [JsonProperty("notes", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Notes { get; set; }

        /// <summary>
        /// Line item level price and adjustments.
        /// </summary>
        [JsonProperty("priceAttributes", NullValueHandling = NullValueHandling.Ignore)]
        public List<PriceAttribute> PriceAttributes { get; set; }

        /// <summary>
        /// The provider of the particular line item, if different from the overall
        /// order. Example: Expedia Order with line item provider ANA.
        /// </summary>
        [JsonProperty("provider", NullValueHandling = NullValueHandling.Ignore)]
        public Merchant Provider { get; set; }

        /// <summary>
        /// Purchase orders like goods, food etc.
        /// </summary>
        [JsonProperty("purchase", NullValueHandling = NullValueHandling.Ignore)]
        public PurchasePurchaseItemExtension Purchase { get; set; }

        /// <summary>
        /// Line item level customers, this could be different from Order level buyer.
        /// Example: User X made restaurant reservation under name of user Y.
        /// </summary>
        [JsonProperty("recipients", NullValueHandling = NullValueHandling.Ignore)]
        public List<UserInfo> Recipients { get; set; }

        /// <summary>
        /// Reservation orders like restaurant, haircut etc.
        /// </summary>
        [JsonProperty("reservation", NullValueHandling = NullValueHandling.Ignore)]
        public ReservationReservationItemExtension Reservation { get; set; }

        /// <summary>
        /// Deprecated. Use vertical level status instead. For example, for purchases,
        /// use PurchaseOrderExtension.status.
        /// User visible label for the state of this line item.
        /// </summary>
        [JsonProperty("userVisibleStateLabel", NullValueHandling = NullValueHandling.Ignore)]
        public string UserVisibleStateLabel { get; set; }

        /// <summary>
        /// Deprecated: Use verticals instead.
        /// Required: Semantic Contents of line item based on its type/vertical.
        /// Every vertical should include its own fulfillment details.
        /// Must be either one of the following values:
        /// google.actions.orders.v3.verticals.purchase.PurchaseItemExtension
        /// google.actions.orders.v3.verticals.reservation.ReservationItemExtension
        /// google.actions.orders.v3.verticals.ticket.TicketItemExtension
        /// </summary>
        [JsonProperty("vertical", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, dynamic> Vertical { get; set; }
    }

    /// <summary>
    /// A product, service or policy disclosure that may be presented to the user.
    /// </summary>
    public partial class Disclosure
    {
        /// <summary>
        /// Content of the disclosure. Weblinks are allowed.
        /// </summary>
        [JsonProperty("disclosureText", NullValueHandling = NullValueHandling.Ignore)]
        public DisclosureText DisclosureText { get; set; }

        /// <summary>
        /// Presentation options for the disclosure.
        /// </summary>
        [JsonProperty("presentationOptions", NullValueHandling = NullValueHandling.Ignore)]
        public DisclosurePresentationOptions PresentationOptions { get; set; }

        /// <summary>
        /// Title of the disclosure. Example: "Safety information".
        /// </summary>
        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public string Title { get; set; }
    }

    /// <summary>
    /// Content of the disclosure. Weblinks are allowed.
    ///
    /// Represents a plain text with web links.
    /// </summary>
    public partial class DisclosureText
    {
        /// <summary>
        /// Text to display, containing placeholders like "{0}" and "{1}" for each
        /// textlink that should be inserted. Example:
        /// "WARNING: This product can expose you to chemicals which are known to the
        /// State of California to cause cancer. For more information go to {0}."
        /// This disclosure text must not contain any promotional or ad-like content.
        /// </summary>
        [JsonProperty("template", NullValueHandling = NullValueHandling.Ignore)]
        public string Template { get; set; }

        /// <summary>
        /// Text links that should be substituted into the template. The first one
        /// will be substituted for "{0}" in the template string, and the second one
        /// for "{1}", etc.
        /// </summary>
        [JsonProperty("textLinks", NullValueHandling = NullValueHandling.Ignore)]
        public List<TextLink> TextLinks { get; set; }
    }

    /// <summary>
    /// A text link that should be substituted into the template.
    /// </summary>
    public partial class TextLink
    {
        /// <summary>
        /// Text that should be displayed to users.
        /// </summary>
        [JsonProperty("displayText", NullValueHandling = NullValueHandling.Ignore)]
        public string DisplayText { get; set; }

        /// <summary>
        /// URL to which users should be directed when the link is activated.
        /// </summary>
        [JsonProperty("url", NullValueHandling = NullValueHandling.Ignore)]
        public string Url { get; set; }
    }

    /// <summary>
    /// Presentation options for the disclosure.
    ///
    /// Options for the presentation of a disclosure.
    /// </summary>
    public partial class DisclosurePresentationOptions
    {
        /// <summary>
        /// Whether the content of the disclosure should be initially expanded.
        /// By default, it is initially collapsed.
        /// </summary>
        [JsonProperty("initiallyExpanded", NullValueHandling = NullValueHandling.Ignore)]
        public bool? InitiallyExpanded { get; set; }

        /// <summary>
        /// Presentation requirement of the disclosure.
        /// </summary>
        [JsonProperty("presentationRequirement", NullValueHandling = NullValueHandling.Ignore)]
        public PresentationRequirement? PresentationRequirement { get; set; }
    }

    /// <summary>
    /// A follow-up action associated with the order or line item.
    /// </summary>
    public partial class FollowUpActionElement
    {
        /// <summary>
        /// Metadata associated with an action.
        /// </summary>
        [JsonProperty("actionMetadata", NullValueHandling = NullValueHandling.Ignore)]
        public ActionMetadata ActionMetadata { get; set; }

        /// <summary>
        /// Action to take.
        /// </summary>
        [JsonProperty("openUrlAction", NullValueHandling = NullValueHandling.Ignore)]
        public V2UiElementsOpenUrlAction OpenUrlAction { get; set; }

        /// <summary>
        /// Title or label of the action, displayed to the user.
        /// Max allowed length is 100 chars.
        /// </summary>
        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public string Title { get; set; }

        /// <summary>
        /// Required: Type of action.
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public FollowUpActionType? Type { get; set; }
    }

    /// <summary>
    /// Metadata associated with an action.
    ///
    /// Related Metadata per action.
    /// </summary>
    public partial class ActionMetadata
    {
        /// <summary>
        /// Time when this action will expire.
        /// </summary>
        [JsonProperty("expireTime", NullValueHandling = NullValueHandling.Ignore)]
        public string ExpireTime { get; set; }
    }

    /// <summary>
    /// Action to take.
    ///
    /// Opens the given url.
    /// </summary>
    public partial class V2UiElementsOpenUrlAction
    {
        /// <summary>
        /// Information about the Android App if the URL is expected to be
        /// fulfilled by an Android App.
        /// </summary>
        [JsonProperty("androidApp", NullValueHandling = NullValueHandling.Ignore)]
        public V2DevicesAndroidApp AndroidApp { get; set; }

        /// <summary>
        /// The url field which could be any of:
        /// - http/https urls for opening an App-linked App or a webpage
        /// </summary>
        [JsonProperty("url", NullValueHandling = NullValueHandling.Ignore)]
        public string Url { get; set; }

        /// <summary>
        /// Indicates a hint for the url type.
        /// </summary>
        [JsonProperty("urlTypeHint", NullValueHandling = NullValueHandling.Ignore)]
        public UrlTypeHint? UrlTypeHint { get; set; }
    }

    /// <summary>
    /// Information about the Android App if the URL is expected to be
    /// fulfilled by an Android App.
    ///
    /// Specification of the Android App for fulfillment restrictions
    /// </summary>
    public partial class V2DevicesAndroidApp
    {
        /// <summary>
        /// Package name
        /// Package name must be specified when specifing Android Fulfillment.
        /// </summary>
        [JsonProperty("packageName", NullValueHandling = NullValueHandling.Ignore)]
        public string PackageName { get; set; }

        /// <summary>
        /// When multiple filters are specified, any filter match will trigger the app.
        /// </summary>
        [JsonProperty("versions", NullValueHandling = NullValueHandling.Ignore)]
        public List<V2DevicesVersionFilter> Versions { get; set; }
    }

    /// <summary>
    /// VersionFilter should be included if specific version/s of the App are
    /// required.
    /// </summary>
    public partial class V2DevicesVersionFilter
    {
        /// <summary>
        /// Max version code, inclusive.
        /// The range considered is [min_version:max_version].
        /// A null range implies any version.
        /// Examples:
        /// To specify a single version use: [target_version:target_version].
        /// To specify any version leave min_version and max_version unspecified.
        /// To specify all versions until max_version, leave min_version unspecified.
        /// To specify all versions from min_version, leave max_version unspecified.
        /// </summary>
        [JsonProperty("maxVersion", NullValueHandling = NullValueHandling.Ignore)]
        public long? MaxVersion { get; set; }

        /// <summary>
        /// Min version code or 0, inclusive.
        /// </summary>
        [JsonProperty("minVersion", NullValueHandling = NullValueHandling.Ignore)]
        public long? MinVersion { get; set; }
    }

    /// <summary>
    /// Small image associated with this item, if any.
    ///
    /// An image displayed in the card.
    ///
    /// The image associated with the merchant.
    ///
    /// URL to a photo of the vehicle.
    /// The photo will be displayed at approximately 256x256px.
    /// Must be a jpg or png.
    /// Optional.
    ///
    /// Performer's images.
    ///
    /// Image associated with the order.
    ///
    /// Character's images.
    /// </summary>
    public partial class V2UiElementsImage
    {
        /// <summary>
        /// A text description of the image to be used for accessibility, e.g. screen
        /// readers.
        /// Required.
        /// </summary>
        [JsonProperty("accessibilityText", NullValueHandling = NullValueHandling.Ignore)]
        public string AccessibilityText { get; set; }

        /// <summary>
        /// The height of the image in pixels.
        /// Optional.
        /// </summary>
        [JsonProperty("height", NullValueHandling = NullValueHandling.Ignore)]
        public long? Height { get; set; }

        /// <summary>
        /// The source url of the image. Images can be JPG, PNG and GIF (animated and
        /// non-animated). For example,`https://www.agentx.com/logo.png`. Required.
        /// </summary>
        [JsonProperty("url", NullValueHandling = NullValueHandling.Ignore)]
        public string Url { get; set; }

        /// <summary>
        /// The width of the image in pixels.
        /// Optional.
        /// </summary>
        [JsonProperty("width", NullValueHandling = NullValueHandling.Ignore)]
        public long? Width { get; set; }
    }

    /// <summary>
    /// Price attribute of an order or a line item.
    ///
    /// Cost of this option.
    ///
    /// Relevant in case of PRICE_CHANGED / INCORRECT_PRICE error type.
    /// </summary>
    public partial class PriceAttribute
    {
        /// <summary>
        /// Monetary amount.
        /// </summary>
        [JsonProperty("amount", NullValueHandling = NullValueHandling.Ignore)]
        public Money Amount { get; set; }

        /// <summary>
        /// The percentage spec, to 1/1000th of a percent.
        /// Eg: 8.750% is represented as 8750, negative percentages represent
        /// percentage discounts.
        /// Deprecating this field. Can consider adding back when a solid usecase is
        /// required.
        /// </summary>
        [JsonProperty("amountMillipercentage", NullValueHandling = NullValueHandling.Ignore)]
        public long? AmountMillipercentage { get; set; }

        /// <summary>
        /// Optional: Id of the lineitem to which this price corresponds.
        /// </summary>
        [JsonProperty("id", NullValueHandling = NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// Required: User displayed string of the price attribute. This is sent and
        /// localized by merchant.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Required: State of the price: Estimate vs Actual.
        /// </summary>
        [JsonProperty("state", NullValueHandling = NullValueHandling.Ignore)]
        public State? State { get; set; }

        /// <summary>
        /// Whether the price is tax included.
        /// </summary>
        [JsonProperty("taxIncluded", NullValueHandling = NullValueHandling.Ignore)]
        public bool? TaxIncluded { get; set; }

        /// <summary>
        /// Required: Type of money attribute.
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public PriceAttributeType? Type { get; set; }
    }

    /// <summary>
    /// Monetary amount.
    ///
    /// Represents an amount of money with its currency type.
    /// </summary>
    public partial class Money
    {
        /// <summary>
        /// Amount in micros.
        /// For example, this field should be set as 1990000 for $1.99.
        /// </summary>
        [JsonProperty("amountInMicros", NullValueHandling = NullValueHandling.Ignore)]
        public string AmountInMicros { get; set; }

        /// <summary>
        /// The 3-letter currency code defined in ISO 4217.
        /// </summary>
        [JsonProperty("currencyCode", NullValueHandling = NullValueHandling.Ignore)]
        public string CurrencyCode { get; set; }
    }

    /// <summary>
    /// The provider of the particular line item, if different from the overall
    /// order. Example: Expedia Order with line item provider ANA.
    ///
    /// Merchant for the cart/order/line item.
    ///
    /// Merchant that facilitated the checkout. This could be different from
    /// a line item level provider. Example: Expedia Order with line item from ANA.
    /// </summary>
    public partial class Merchant
    {
        /// <summary>
        /// Merchant's address.
        /// </summary>
        [JsonProperty("address", NullValueHandling = NullValueHandling.Ignore)]
        public V2Location Address { get; set; }

        /// <summary>
        /// Optional ID assigned to merchant if any.
        /// </summary>
        [JsonProperty("id", NullValueHandling = NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// The image associated with the merchant.
        /// </summary>
        [JsonProperty("image", NullValueHandling = NullValueHandling.Ignore)]
        public V2UiElementsImage Image { get; set; }

        /// <summary>
        /// The name of the merchant like "Panera Bread".
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Merchant's phone numbers.
        /// </summary>
        [JsonProperty("phoneNumbers", NullValueHandling = NullValueHandling.Ignore)]
        public List<PhoneNumber> PhoneNumbers { get; set; }
    }

    /// <summary>
    /// Merchant's address.
    ///
    /// Container that represents a location.
    ///
    /// Pickup or delivery location.
    ///
    /// Location of the service/event.
    ///
    /// The location where the event is happening, or an organization is located.
    /// </summary>
    public partial class V2Location
    {
        /// <summary>
        /// City.
        /// Requires the DEVICE_PRECISE_LOCATION or
        /// DEVICE_COARSE_LOCATION permission.
        /// </summary>
        [JsonProperty("city", NullValueHandling = NullValueHandling.Ignore)]
        public string City { get; set; }

        /// <summary>
        /// Geo coordinates.
        /// Requires the DEVICE_PRECISE_LOCATION permission.
        /// </summary>
        [JsonProperty("coordinates", NullValueHandling = NullValueHandling.Ignore)]
        public LatLng Coordinates { get; set; }

        /// <summary>
        /// Display address, e.g., "1600 Amphitheatre Pkwy, Mountain View, CA 94043".
        /// Requires the DEVICE_PRECISE_LOCATION permission.
        /// </summary>
        [JsonProperty("formattedAddress", NullValueHandling = NullValueHandling.Ignore)]
        public string FormattedAddress { get; set; }

        /// <summary>
        /// Name of the place.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Notes about the location.
        /// </summary>
        [JsonProperty("notes", NullValueHandling = NullValueHandling.Ignore)]
        public string Notes { get; set; }

        /// <summary>
        /// Phone number of the location, e.g. contact number of business location or
        /// phone number for delivery location.
        /// </summary>
        [JsonProperty("phoneNumber", NullValueHandling = NullValueHandling.Ignore)]
        public string PhoneNumber { get; set; }

        /// <summary>
        /// place_id is used with Places API to fetch details of a place.
        /// See https://developers.google.com/places/web-service/place-id
        /// </summary>
        [JsonProperty("placeId", NullValueHandling = NullValueHandling.Ignore)]
        public string PlaceId { get; set; }

        /// <summary>
        /// Postal address.
        /// Requires the DEVICE_PRECISE_LOCATION or
        /// DEVICE_COARSE_LOCATION permission.
        /// </summary>
        [JsonProperty("postalAddress", NullValueHandling = NullValueHandling.Ignore)]
        public PostalAddress PostalAddress { get; set; }

        /// <summary>
        /// Zip code.
        /// Requires the DEVICE_PRECISE_LOCATION or
        /// DEVICE_COARSE_LOCATION permission.
        /// </summary>
        [JsonProperty("zipCode", NullValueHandling = NullValueHandling.Ignore)]
        public string ZipCode { get; set; }
    }

    /// <summary>
    /// Geo coordinates.
    /// Requires the DEVICE_PRECISE_LOCATION permission.
    ///
    /// An object representing a latitude/longitude pair. This is expressed as a pair
    /// of doubles representing degrees latitude and degrees longitude. Unless
    /// specified otherwise, this must conform to the
    /// <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
    /// standard</a>. Values must be within normalized ranges.
    /// </summary>
    public partial class LatLng
    {
        /// <summary>
        /// The latitude in degrees. It must be in the range [-90.0, +90.0].
        /// </summary>
        [JsonProperty("latitude", NullValueHandling = NullValueHandling.Ignore)]
        public double? Latitude { get; set; }

        /// <summary>
        /// The longitude in degrees. It must be in the range [-180.0, +180.0].
        /// </summary>
        [JsonProperty("longitude", NullValueHandling = NullValueHandling.Ignore)]
        public double? Longitude { get; set; }
    }

    /// <summary>
    /// Postal address.
    /// Requires the DEVICE_PRECISE_LOCATION or
    /// DEVICE_COARSE_LOCATION permission.
    ///
    /// Represents a postal address, e.g. for postal delivery or payments addresses.
    /// Given a postal address, a postal service can deliver items to a premise, P.O.
    /// Box or similar.
    /// It is not intended to model geographical locations (roads, towns,
    /// mountains).
    ///
    /// In typical usage an address would be created via user input or from importing
    /// existing data, depending on the type of process.
    ///
    /// Advice on address input / editing:
    /// - Use an i18n-ready address widget such as
    /// https://github.com/google/libaddressinput)
    /// - Users should not be presented with UI elements for input or editing of
    /// fields outside countries where that field is used.
    ///
    /// For more guidance on how to use this schema, please see:
    /// https://support.google.com/business/answer/6397478
    /// </summary>
    public partial class PostalAddress
    {
        /// <summary>
        /// Unstructured address lines describing the lower levels of an address.
        ///
        /// Because values in address_lines do not have type information and may
        /// sometimes contain multiple values in a single field (e.g.
        /// "Austin, TX"), it is important that the line order is clear. The order of
        /// address lines should be "envelope order" for the country/region of the
        /// address. In places where this can vary (e.g. Japan), address_language is
        /// used to make it explicit (e.g. "ja" for large-to-small ordering and
        /// "ja-Latn" or "en" for small-to-large). This way, the most specific line of
        /// an address can be selected based on the language.
        ///
        /// The minimum permitted structural representation of an address consists
        /// of a region_code with all remaining information placed in the
        /// address_lines. It would be possible to format such an address very
        /// approximately without geocoding, but no semantic reasoning could be
        /// made about any of the address components until it was at least
        /// partially resolved.
        ///
        /// Creating an address only containing a region_code and address_lines, and
        /// then geocoding is the recommended way to handle completely unstructured
        /// addresses (as opposed to guessing which parts of the address should be
        /// localities or administrative areas).
        /// </summary>
        [JsonProperty("addressLines", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> AddressLines { get; set; }

        /// <summary>
        /// Optional. Highest administrative subdivision which is used for postal
        /// addresses of a country or region.
        /// For example, this can be a state, a province, an oblast, or a prefecture.
        /// Specifically, for Spain this is the province and not the autonomous
        /// community (e.g. "Barcelona" and not "Catalonia").
        /// Many countries don't use an administrative area in postal addresses. E.g.
        /// in Switzerland this should be left unpopulated.
        /// </summary>
        [JsonProperty("administrativeArea", NullValueHandling = NullValueHandling.Ignore)]
        public string AdministrativeArea { get; set; }

        /// <summary>
        /// Optional. BCP-47 language code of the contents of this address (if
        /// known). This is often the UI language of the input form or is expected
        /// to match one of the languages used in the address' country/region, or their
        /// transliterated equivalents.
        /// This can affect formatting in certain countries, but is not critical
        /// to the correctness of the data and will never affect any validation or
        /// other non-formatting related operations.
        ///
        /// If this value is not known, it should be omitted (rather than specifying a
        /// possibly incorrect default).
        ///
        /// Examples: "zh-Hant", "ja", "ja-Latn", "en".
        /// </summary>
        [JsonProperty("languageCode", NullValueHandling = NullValueHandling.Ignore)]
        public string LanguageCode { get; set; }

        /// <summary>
        /// Optional. Generally refers to the city/town portion of the address.
        /// Examples: US city, IT comune, UK post town.
        /// In regions of the world where localities are not well defined or do not fit
        /// into this structure well, leave locality empty and use address_lines.
        /// </summary>
        [JsonProperty("locality", NullValueHandling = NullValueHandling.Ignore)]
        public string Locality { get; set; }

        /// <summary>
        /// Optional. The name of the organization at the address.
        /// </summary>
        [JsonProperty("organization", NullValueHandling = NullValueHandling.Ignore)]
        public string Organization { get; set; }

        /// <summary>
        /// Optional. Postal code of the address. Not all countries use or require
        /// postal codes to be present, but where they are used, they may trigger
        /// additional validation with other parts of the address (e.g. state/zip
        /// validation in the U.S.A.).
        /// </summary>
        [JsonProperty("postalCode", NullValueHandling = NullValueHandling.Ignore)]
        public string PostalCode { get; set; }

        /// <summary>
        /// Optional. The recipient at the address.
        /// This field may, under certain circumstances, contain multiline information.
        /// For example, it might contain "care of" information.
        /// </summary>
        [JsonProperty("recipients", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Recipients { get; set; }

        /// <summary>
        /// Required. CLDR region code of the country/region of the address. This
        /// is never inferred and it is up to the user to ensure the value is
        /// correct. See http://cldr.unicode.org/ and
        /// http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
        /// for details. Example: "CH" for Switzerland.
        /// </summary>
        [JsonProperty("regionCode", NullValueHandling = NullValueHandling.Ignore)]
        public string RegionCode { get; set; }

        /// <summary>
        /// The schema revision of the `PostalAddress`. This must be set to 0, which is
        /// the latest revision.
        ///
        /// All new revisions **must** be backward compatible with old revisions.
        /// </summary>
        [JsonProperty("revision", NullValueHandling = NullValueHandling.Ignore)]
        public long? Revision { get; set; }

        /// <summary>
        /// Optional. Additional, country-specific, sorting code. This is not used
        /// in most regions. Where it is used, the value is either a string like
        /// "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
        /// alone, representing the "sector code" (Jamaica), "delivery area indicator"
        /// (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
        /// </summary>
        [JsonProperty("sortingCode", NullValueHandling = NullValueHandling.Ignore)]
        public string SortingCode { get; set; }

        /// <summary>
        /// Optional. Sublocality of the address.
        /// For example, this can be neighborhoods, boroughs, districts.
        /// </summary>
        [JsonProperty("sublocality", NullValueHandling = NullValueHandling.Ignore)]
        public string Sublocality { get; set; }
    }

    /// <summary>
    /// Purchase orders like goods, food etc.
    ///
    /// Line item contents of Purchase Vertical.
    /// </summary>
    public partial class PurchasePurchaseItemExtension
    {
        /// <summary>
        /// Any extra fields exchanged between merchant and google.
        /// Note: Use of this extension is highly discouraged. Based on the
        /// use-case/circumstances, consider one of the following:
        /// 1. Define fields in the PurchaseItemExtension if it could be used for other
        /// use-cases (ie. generic capability/functionality).
        /// 2. Use vertical_extension if it is specific to a custom, non-generic
        /// use-case/feature.
        /// </summary>
        [JsonProperty("extension", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, dynamic> Extension { get; set; }

        /// <summary>
        /// Fulfillment info for this line item. If unset, this line item
        /// inherits order level fulfillment info.
        /// </summary>
        [JsonProperty("fulfillmentInfo", NullValueHandling = NullValueHandling.Ignore)]
        public PurchasePurchaseFulfillmentInfo FulfillmentInfo { get; set; }

        /// <summary>
        /// Additional add-ons or sub-items.
        /// </summary>
        [JsonProperty("itemOptions", NullValueHandling = NullValueHandling.Ignore)]
        public List<PurchaseItemOption> ItemOptions { get; set; }

        /// <summary>
        /// Details about the product.
        /// </summary>
        [JsonProperty("productDetails", NullValueHandling = NullValueHandling.Ignore)]
        public PurchaseProductDetails ProductDetails { get; set; }

        /// <summary>
        /// Product or offer id associated with this line item.
        /// </summary>
        [JsonProperty("productId", NullValueHandling = NullValueHandling.Ignore)]
        public string ProductId { get; set; }

        /// <summary>
        /// Quantity of the item.
        /// </summary>
        [JsonProperty("quantity", NullValueHandling = NullValueHandling.Ignore)]
        public long? Quantity { get; set; }

        /// <summary>
        /// Returns info for this line item. If unset, this line item
        /// inherits order level returns info.
        /// </summary>
        [JsonProperty("returnsInfo", NullValueHandling = NullValueHandling.Ignore)]
        public PurchasePurchaseReturnsInfo ReturnsInfo { get; set; }

        /// <summary>
        /// Required: Line item level status.
        /// </summary>
        [JsonProperty("status", NullValueHandling = NullValueHandling.Ignore)]
        public PurchaseStatus? Status { get; set; }

        /// <summary>
        /// Required: Type of purchase.
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public PurchaseType? Type { get; set; }

        /// <summary>
        /// Unit measure.
        /// Specifies the size of the item in chosen units. The size, together with
        /// the active price is used to determine the unit price.
        /// </summary>
        [JsonProperty("unitMeasure", NullValueHandling = NullValueHandling.Ignore)]
        public PurchaseMerchantUnitMeasure UnitMeasure { get; set; }

        /// <summary>
        /// Required: User visible label/string for the status.
        /// Max allowed length is 50 chars.
        /// </summary>
        [JsonProperty("userVisibleStatusLabel", NullValueHandling = NullValueHandling.Ignore)]
        public string UserVisibleStatusLabel { get; set; }
    }

    /// <summary>
    /// Fulfillment info for this line item. If unset, this line item
    /// inherits order level fulfillment info.
    ///
    /// Fulfillment info associated with a purchase order or a particular line item.
    ///
    /// Fulfillment info for the order.
    /// </summary>
    public partial class PurchasePurchaseFulfillmentInfo
    {
        /// <summary>
        /// A window if a time-range is specified or ETA if single time specified.
        /// Expected delivery or pickup time.
        /// </summary>
        [JsonProperty("expectedFulfillmentTime", NullValueHandling = NullValueHandling.Ignore)]
        public Time ExpectedFulfillmentTime { get; set; }

        /// <summary>
        /// A window if a time-range is specified or ETA if single time specified.
        /// Expected time to prepare the food. Single-time preferred.
        /// </summary>
        [JsonProperty("expectedPreparationTime", NullValueHandling = NullValueHandling.Ignore)]
        public Time ExpectedPreparationTime { get; set; }

        /// <summary>
        /// Time at which this fulfillment option expires.
        /// </summary>
        [JsonProperty("expireTime", NullValueHandling = NullValueHandling.Ignore)]
        public string ExpireTime { get; set; }

        /// <summary>
        /// User contact for this fulfillment.
        /// </summary>
        [JsonProperty("fulfillmentContact", NullValueHandling = NullValueHandling.Ignore)]
        public UserInfo FulfillmentContact { get; set; }

        /// <summary>
        /// Required: The type of fulfillment.
        /// </summary>
        [JsonProperty("fulfillmentType", NullValueHandling = NullValueHandling.Ignore)]
        public FulfillmentType? FulfillmentType { get; set; }

        /// <summary>
        /// Unique identifier for this service option.
        /// </summary>
        [JsonProperty("id", NullValueHandling = NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// Pickup or delivery location.
        /// </summary>
        [JsonProperty("location", NullValueHandling = NullValueHandling.Ignore)]
        public V2Location Location { get; set; }

        /// <summary>
        /// Additional information regarding how order would be picked. This field
        /// would only be applicable when fulfillment type is PICKUP.
        /// </summary>
        [JsonProperty("pickupInfo", NullValueHandling = NullValueHandling.Ignore)]
        public PurchasePickupInfo PickupInfo { get; set; }

        /// <summary>
        /// Cost of this option.
        /// </summary>
        [JsonProperty("price", NullValueHandling = NullValueHandling.Ignore)]
        public PriceAttribute Price { get; set; }

        /// <summary>
        /// Name of the shipping method selected by the user.
        /// </summary>
        [JsonProperty("shippingMethodName", NullValueHandling = NullValueHandling.Ignore)]
        public string ShippingMethodName { get; set; }

        /// <summary>
        /// StoreCode of the location.
        /// Example: Walmart is the merchant and store_code is the walmart store
        /// where fulfillment happened.
        /// https://support.google.com/business/answer/3370250?ref_topic=4596653.
        /// </summary>
        [JsonProperty("storeCode", NullValueHandling = NullValueHandling.Ignore)]
        public string StoreCode { get; set; }
    }

    /// <summary>
    /// A window if a time-range is specified or ETA if single time specified.
    /// Expected delivery or pickup time.
    ///
    /// Time construct to represent time of an event to use when displaying an order
    /// to the user.
    ///
    /// A window if a time-range is specified or ETA if single time specified.
    /// Expected time to prepare the food. Single-time preferred.
    ///
    /// Time when the service/event is scheduled to occur.
    /// Can be a time range, a date, or an exact date time.
    ///
    /// Time range that is acceptable to the user.
    ///
    /// Entry time, which might be different from the event start time. e.g. the
    /// event starts at 9am, but entry time is 8:30am.
    ///
    /// End time.
    ///
    /// Start time.
    /// </summary>
    public partial class Time
    {
        /// <summary>
        /// Represents an order-event time like reservation time, delivery time and so
        /// on. Could be a duration (start & end time), just the date, date time etc.
        /// Refer https://en.wikipedia.org/wiki/ISO_8601 for all supported formats.
        /// </summary>
        [JsonProperty("timeIso8601", NullValueHandling = NullValueHandling.Ignore)]
        public string TimeIso8601 { get; set; }
    }

    /// <summary>
    /// Additional information regarding how order would be picked. This field
    /// would only be applicable when fulfillment type is PICKUP.
    ///
    /// Details about how an order is picked up. It includes details such as pickup
    /// type and additional metadata attached with each type, if any.
    /// </summary>
    public partial class PurchasePickupInfo
    {
        /// <summary>
        /// List of various methods supported by partner to support check-in.
        /// </summary>
        [JsonProperty("checkInInfo", NullValueHandling = NullValueHandling.Ignore)]
        public List<CommonCheckInInfo> CheckInInfo { get; set; }

        /// <summary>
        /// Details specific to the curbside information. If pickup_type is not
        /// "CURBSIDE", this field would be ignored.
        /// </summary>
        [JsonProperty("curbsideInfo", NullValueHandling = NullValueHandling.Ignore)]
        public PurchaseCurbsideInfo CurbsideInfo { get; set; }

        /// <summary>
        /// Pick up method, such as INSTORE, CURBSIDE etc.
        /// </summary>
        [JsonProperty("pickupType", NullValueHandling = NullValueHandling.Ignore)]
        public PickupType? PickupType { get; set; }
    }

    /// <summary>
    /// Metadata required by partner to support a checkin method.
    /// </summary>
    public partial class CommonCheckInInfo
    {
        /// <summary>
        /// Method used to send checkin instructions.
        /// </summary>
        [JsonProperty("checkInType", NullValueHandling = NullValueHandling.Ignore)]
        public CheckInType? CheckInType { get; set; }
    }

    /// <summary>
    /// Details specific to the curbside information. If pickup_type is not
    /// "CURBSIDE", this field would be ignored.
    ///
    /// Details about how curbside order would be facilitated.
    /// </summary>
    public partial class PurchaseCurbsideInfo
    {
        /// <summary>
        /// Partners need additional information to facilitate curbside pickup
        /// orders. Depending upon what fulfillment type is chosen, corresponding
        /// details would be collected from the user.
        /// </summary>
        [JsonProperty("curbsideFulfillmentType", NullValueHandling = NullValueHandling.Ignore)]
        public CurbsideFulfillmentType? CurbsideFulfillmentType { get; set; }

        /// <summary>
        /// Vehicle details of the user placing the order.
        /// </summary>
        [JsonProperty("userVehicle", NullValueHandling = NullValueHandling.Ignore)]
        public CommonVehicle UserVehicle { get; set; }
    }

    /// <summary>
    /// Vehicle details of the user placing the order.
    ///
    /// Details about a vehicle
    /// </summary>
    public partial class CommonVehicle
    {
        /// <summary>
        /// Vehicle color name, eg. black
        /// Optional.
        /// </summary>
        [JsonProperty("colorName", NullValueHandling = NullValueHandling.Ignore)]
        public string ColorName { get; set; }

        /// <summary>
        /// URL to a photo of the vehicle.
        /// The photo will be displayed at approximately 256x256px.
        /// Must be a jpg or png.
        /// Optional.
        /// </summary>
        [JsonProperty("image", NullValueHandling = NullValueHandling.Ignore)]
        public V2UiElementsImage Image { get; set; }

        /// <summary>
        /// Vehicle license plate number (e.g. "1ABC234").
        /// Required.
        /// </summary>
        [JsonProperty("licensePlate", NullValueHandling = NullValueHandling.Ignore)]
        public string LicensePlate { get; set; }

        /// <summary>
        /// Vehicle make (e.g. "Honda").
        /// This is displayed to the user and must be localized.
        /// Required.
        /// </summary>
        [JsonProperty("make", NullValueHandling = NullValueHandling.Ignore)]
        public string Make { get; set; }

        /// <summary>
        /// Vehicle model (e.g. "Grom").
        /// This is displayed to the user and must be localized.
        /// Required.
        /// </summary>
        [JsonProperty("model", NullValueHandling = NullValueHandling.Ignore)]
        public string Model { get; set; }
    }

    /// <summary>
    /// Represents add-ons or sub-items.
    /// </summary>
    public partial class PurchaseItemOption
    {
        /// <summary>
        /// For options that are items, unique item id.
        /// </summary>
        [JsonProperty("id", NullValueHandling = NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// Option name.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Note related to the option.
        /// </summary>
        [JsonProperty("note", NullValueHandling = NullValueHandling.Ignore)]
        public string Note { get; set; }

        /// <summary>
        /// Option total price.
        /// </summary>
        [JsonProperty("prices", NullValueHandling = NullValueHandling.Ignore)]
        public List<PriceAttribute> Prices { get; set; }

        /// <summary>
        /// Product or offer id associated with this option.
        /// </summary>
        [JsonProperty("productId", NullValueHandling = NullValueHandling.Ignore)]
        public string ProductId { get; set; }

        /// <summary>
        /// For options that are items, quantity.
        /// </summary>
        [JsonProperty("quantity", NullValueHandling = NullValueHandling.Ignore)]
        public long? Quantity { get; set; }

        /// <summary>
        /// To define other nested sub options.
        /// </summary>
        [JsonProperty("subOptions", NullValueHandling = NullValueHandling.Ignore)]
        public List<PurchaseItemOption> SubOptions { get; set; }
    }

    /// <summary>
    /// Details about the product.
    /// </summary>
    public partial class PurchaseProductDetails
    {
        /// <summary>
        /// Global Trade Item Number of the product.
        /// Useful if offerId is not present in Merchant Center. Optional.
        /// </summary>
        [JsonProperty("gtin", NullValueHandling = NullValueHandling.Ignore)]
        public string Gtin { get; set; }

        /// <summary>
        /// Price look-up codes, commonly called PLU codes, PLU numbers, PLUs,
        /// produce codes, or produce labels, are a system of numbers that
        /// uniquely identify bulk produce sold in grocery stores and supermarkets.
        /// </summary>
        [JsonProperty("plu", NullValueHandling = NullValueHandling.Ignore)]
        public string Plu { get; set; }

        /// <summary>
        /// Merchant-provided details about the product,
        /// e.g. { "allergen": "peanut" }.
        /// Useful if offerId is not present in Merchant Center. Optional.
        /// </summary>
        [JsonProperty("productAttributes", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, dynamic> ProductAttributes { get; set; }

        /// <summary>
        /// Product or offer id associated with this line item.
        /// </summary>
        [JsonProperty("productId", NullValueHandling = NullValueHandling.Ignore)]
        public string ProductId { get; set; }

        /// <summary>
        /// Product category defined by the merchant.
        /// E.g. "Home > Grocery > Dairy & Eggs > Milk > Whole Milk"
        /// </summary>
        [JsonProperty("productType", NullValueHandling = NullValueHandling.Ignore)]
        public string ProductType { get; set; }
    }

    /// <summary>
    /// Returns info for this line item. If unset, this line item
    /// inherits order level returns info.
    ///
    /// Returns info associated with an order or a particular line item.
    ///
    /// Return info for the order.
    /// </summary>
    public partial class PurchasePurchaseReturnsInfo
    {
        /// <summary>
        /// Return is allowed within that many days.
        /// </summary>
        [JsonProperty("daysToReturn", NullValueHandling = NullValueHandling.Ignore)]
        public long? DaysToReturn { get; set; }

        /// <summary>
        /// If true, return is allowed.
        /// </summary>
        [JsonProperty("isReturnable", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsReturnable { get; set; }

        /// <summary>
        /// Link to the return policy.
        /// </summary>
        [JsonProperty("policyUrl", NullValueHandling = NullValueHandling.Ignore)]
        public string PolicyUrl { get; set; }
    }

    /// <summary>
    /// Unit measure.
    /// Specifies the size of the item in chosen units. The size, together with
    /// the active price is used to determine the unit price.
    ///
    /// Merchant unit pricing measure.
    /// </summary>
    public partial class PurchaseMerchantUnitMeasure
    {
        /// <summary>
        /// Value: Example 1.2.
        /// </summary>
        [JsonProperty("measure", NullValueHandling = NullValueHandling.Ignore)]
        public double? Measure { get; set; }

        /// <summary>
        /// Unit: Example POUND, GRAM.
        /// </summary>
        [JsonProperty("unit", NullValueHandling = NullValueHandling.Ignore)]
        public Unit? Unit { get; set; }
    }

    /// <summary>
    /// Reservation orders like restaurant, haircut etc.
    ///
    /// Line item contents for reservation orders like restaurant, haircut etc.
    /// </summary>
    public partial class ReservationReservationItemExtension
    {
        /// <summary>
        /// Confirmation code for this reservation.
        /// </summary>
        [JsonProperty("confirmationCode", NullValueHandling = NullValueHandling.Ignore)]
        public string ConfirmationCode { get; set; }

        /// <summary>
        /// Location of the service/event.
        /// </summary>
        [JsonProperty("location", NullValueHandling = NullValueHandling.Ignore)]
        public V2Location Location { get; set; }

        /// <summary>
        /// The number of people.
        /// </summary>
        [JsonProperty("partySize", NullValueHandling = NullValueHandling.Ignore)]
        public long? PartySize { get; set; }

        /// <summary>
        /// Time when the service/event is scheduled to occur.
        /// Can be a time range, a date, or an exact date time.
        /// </summary>
        [JsonProperty("reservationTime", NullValueHandling = NullValueHandling.Ignore)]
        public Time ReservationTime { get; set; }

        /// <summary>
        /// Staff facilitators who will be servicing the reservation.
        /// Ex. The hairstylist.
        /// </summary>
        [JsonProperty("staffFacilitators", NullValueHandling = NullValueHandling.Ignore)]
        public List<ReservationStaffFacilitator> StaffFacilitators { get; set; }

        /// <summary>
        /// Required: Reservation status.
        /// </summary>
        [JsonProperty("status", NullValueHandling = NullValueHandling.Ignore)]
        public ReservationStatus? Status { get; set; }

        /// <summary>
        /// Type of reservation.
        /// May be unset if none of the type options is applicable.
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public ReservationType? Type { get; set; }

        /// <summary>
        /// Time range that is acceptable to the user.
        /// </summary>
        [JsonProperty("userAcceptableTimeRange", NullValueHandling = NullValueHandling.Ignore)]
        public Time UserAcceptableTimeRange { get; set; }

        /// <summary>
        /// Required: User visible label/string for the status.
        /// Max allowed length is 50 chars.
        /// </summary>
        [JsonProperty("userVisibleStatusLabel", NullValueHandling = NullValueHandling.Ignore)]
        public string UserVisibleStatusLabel { get; set; }
    }

    /// <summary>
    /// Information about service person.
    /// </summary>
    public partial class ReservationStaffFacilitator
    {
        /// <summary>
        /// Performer's images.
        /// </summary>
        [JsonProperty("image", NullValueHandling = NullValueHandling.Ignore)]
        public V2UiElementsImage Image { get; set; }

        /// <summary>
        /// The staff facilitator's name. Ex. "John Smith"
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }
    }

    /// <summary>
    /// Payment related data for the order.
    ///
    /// Payment data related to an order.
    /// </summary>
    public partial class PaymentData
    {
        /// <summary>
        /// Payment information regarding the order that's useful for user facing
        /// interaction.
        /// </summary>
        [JsonProperty("paymentInfo", NullValueHandling = NullValueHandling.Ignore)]
        public PaymentInfo PaymentInfo { get; set; }

        /// <summary>
        /// Payment result that's used by integrator for completing a transaction.
        /// This field will be populated by Actions on Google if the checkout
        /// experience is managed by Actions-on-Google.
        /// </summary>
        [JsonProperty("paymentResult", NullValueHandling = NullValueHandling.Ignore)]
        public PaymentResult PaymentResult { get; set; }
    }

    /// <summary>
    /// Payment information regarding the order that's useful for user facing
    /// interaction.
    ///
    /// Payment information regarding the order being made.
    /// This proto captures information that's useful for user facing interaction.
    /// </summary>
    public partial class PaymentInfo
    {
        /// <summary>
        /// The display info of the payment method used for the transaction.
        /// </summary>
        [JsonProperty("paymentMethodDisplayInfo", NullValueHandling = NullValueHandling.Ignore)]
        public PaymentMethodDisplayInfo PaymentMethodDisplayInfo { get; set; }

        /// <summary>
        /// Provenance of the payment method used for the transaction.
        /// User may have registered the same payment method with both google and
        /// merchant.
        /// </summary>
        [JsonProperty("paymentMethodProvenance", NullValueHandling = NullValueHandling.Ignore)]
        public PaymentMethodProvenance? PaymentMethodProvenance { get; set; }
    }

    /// <summary>
    /// The display info of the payment method used for the transaction.
    ///
    /// Payment result used by integrator for completing a transaction.
    /// </summary>
    public partial class PaymentMethodDisplayInfo
    {
        /// <summary>
        /// User visible name of the payment method. For example,
        /// VISA **** 1234
        /// Checking acct **** 5678
        /// </summary>
        [JsonProperty("paymentMethodDisplayName", NullValueHandling = NullValueHandling.Ignore)]
        public string PaymentMethodDisplayName { get; set; }

        /// <summary>
        /// Payment method name to be spoken out to the user for voice-only
        /// assistant devices. For example,
        /// "visa ending in one two three four", or
        /// "checking account ending in five six seven eight".
        /// Note: This is the voice-optimized string to be used instead of the
        /// payment_method_display_name for voice-only assistant devices. If this
        /// string is not set, payment_method_display_name will instead be spoken out
        /// to the user.
        /// </summary>
        [JsonProperty("paymentMethodVoiceName", NullValueHandling = NullValueHandling.Ignore)]
        public string PaymentMethodVoiceName { get; set; }

        /// <summary>
        /// The type of the payment.
        /// </summary>
        [JsonProperty("paymentType", NullValueHandling = NullValueHandling.Ignore)]
        public PaymentType? PaymentType { get; set; }
    }

    /// <summary>
    /// Payment result that's used by integrator for completing a transaction.
    /// This field will be populated by Actions on Google if the checkout
    /// experience is managed by Actions-on-Google.
    ///
    /// Payment result used by integrator for completing a transaction.
    /// </summary>
    public partial class PaymentResult
    {
        /// <summary>
        /// Google provided payment method data.
        /// If your payment processor is listed as Google supported payment processor
        /// here: https://developers.google.com/pay/api/ Navigate to your payment
        /// processor through the link to find out more details.
        /// Otherwise, refer to following documentation for payload details.
        /// https://developers.google.com/pay/api/payment-data-cryptography
        /// </summary>
        [JsonProperty("googlePaymentData", NullValueHandling = NullValueHandling.Ignore)]
        public string GooglePaymentData { get; set; }

        /// <summary>
        /// Merchant/Action provided payment method chosen by user.
        /// </summary>
        [JsonProperty("merchantPaymentMethodId", NullValueHandling = NullValueHandling.Ignore)]
        public string MerchantPaymentMethodId { get; set; }
    }

    /// <summary>
    /// Promotions/Offers that were added to the cart.
    /// </summary>
    public partial class Promotion
    {
        /// <summary>
        /// Required: Coupon code applied to this offer.
        /// </summary>
        [JsonProperty("coupon", NullValueHandling = NullValueHandling.Ignore)]
        public string Coupon { get; set; }
    }

    /// <summary>
    /// Purchase order
    ///
    /// Order extension for purchase vertical. These properties are applicable to
    /// all line items inside order, unless overridden in a line item.
    /// </summary>
    public partial class PurchasePurchaseOrderExtension
    {
        /// <summary>
        /// Optional: Errors because of which this order was rejected.
        /// </summary>
        [JsonProperty("errors", NullValueHandling = NullValueHandling.Ignore)]
        public List<PurchasePurchaseError> Errors { get; set; }

        /// <summary>
        /// Any extra fields exchanged between merchant and google.
        /// Note: Use of this extension is highly discouraged. Based on the
        /// use-case/circumstances, consider one of the following:
        /// 1. Define fields in the PurchaseOrderExtension if it could be used for
        /// other use-cases (ie. generic capability/functionality).
        /// 2. Use vertical_extension if it is specific to a custom, non-generic
        /// use-case/feature.
        /// </summary>
        [JsonProperty("extension", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, dynamic> Extension { get; set; }

        /// <summary>
        /// Fulfillment info for the order.
        /// </summary>
        [JsonProperty("fulfillmentInfo", NullValueHandling = NullValueHandling.Ignore)]
        public PurchasePurchaseFulfillmentInfo FulfillmentInfo { get; set; }

        /// <summary>
        /// Location of the purchase (in-store / online)
        /// </summary>
        [JsonProperty("purchaseLocationType", NullValueHandling = NullValueHandling.Ignore)]
        public PurchaseLocationType? PurchaseLocationType { get; set; }

        /// <summary>
        /// Return info for the order.
        /// </summary>
        [JsonProperty("returnsInfo", NullValueHandling = NullValueHandling.Ignore)]
        public PurchasePurchaseReturnsInfo ReturnsInfo { get; set; }

        /// <summary>
        /// Required: Overall Status for the order.
        /// </summary>
        [JsonProperty("status", NullValueHandling = NullValueHandling.Ignore)]
        public PurchaseStatus? Status { get; set; }

        /// <summary>
        /// Required: Type of purchase.
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public PurchaseType? Type { get; set; }

        /// <summary>
        /// User visible label/string for the status.
        /// Max allowed length is 50 chars.
        /// </summary>
        [JsonProperty("userVisibleStatusLabel", NullValueHandling = NullValueHandling.Ignore)]
        public string UserVisibleStatusLabel { get; set; }
    }

    /// <summary>
    /// Errors that a purchase order can be rejected for.
    /// </summary>
    public partial class PurchasePurchaseError
    {
        /// <summary>
        /// Available quantity now. Applicable in case of AVAILABILITY_CHANGED.
        /// </summary>
        [JsonProperty("availableQuantity", NullValueHandling = NullValueHandling.Ignore)]
        public long? AvailableQuantity { get; set; }

        /// <summary>
        /// Additional error description.
        /// </summary>
        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// Entity Id that corresponds to the error. Example this can correspond to
        /// LineItemId / ItemOptionId.
        /// </summary>
        [JsonProperty("entityId", NullValueHandling = NullValueHandling.Ignore)]
        public string EntityId { get; set; }

        /// <summary>
        /// Required: This represents the granular reason why an order gets rejected by
        /// the merchant.
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public ErrorType? Type { get; set; }

        /// <summary>
        /// Relevant in case of PRICE_CHANGED / INCORRECT_PRICE error type.
        /// </summary>
        [JsonProperty("updatedPrice", NullValueHandling = NullValueHandling.Ignore)]
        public PriceAttribute UpdatedPrice { get; set; }
    }

    /// <summary>
    /// Ticket order
    ///
    /// Order contents for ticket orders like movie, sports etc.
    /// </summary>
    public partial class TicketTicketOrderExtension
    {
        /// <summary>
        /// The event applied to all line item tickets.
        /// </summary>
        [JsonProperty("ticketEvent", NullValueHandling = NullValueHandling.Ignore)]
        public TicketTicketEvent TicketEvent { get; set; }
    }

    /// <summary>
    /// The event applied to all line item tickets.
    ///
    /// Represents a single event.
    /// </summary>
    public partial class TicketTicketEvent
    {
        /// <summary>
        /// Description of the event.
        /// </summary>
        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// Entry time, which might be different from the event start time. e.g. the
        /// event starts at 9am, but entry time is 8:30am.
        /// </summary>
        [JsonProperty("doorTime", NullValueHandling = NullValueHandling.Ignore)]
        public Time DoorTime { get; set; }

        /// <summary>
        /// End time.
        /// </summary>
        [JsonProperty("endDate", NullValueHandling = NullValueHandling.Ignore)]
        public Time EndDate { get; set; }

        /// <summary>
        /// The characters related to this event. It can be directors or actors of a
        /// movie event, or performers of a concert, etc.
        /// </summary>
        [JsonProperty("eventCharacters", NullValueHandling = NullValueHandling.Ignore)]
        public List<TicketEventCharacter> EventCharacters { get; set; }

        /// <summary>
        /// The location where the event is happening, or an organization is located.
        /// </summary>
        [JsonProperty("location", NullValueHandling = NullValueHandling.Ignore)]
        public V2Location Location { get; set; }

        /// <summary>
        /// Required: Name of the event. For example, if the event is a movie, this
        /// should be the movie name.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Start time.
        /// </summary>
        [JsonProperty("startDate", NullValueHandling = NullValueHandling.Ignore)]
        public Time StartDate { get; set; }

        /// <summary>
        /// Required: Type of the ticket event, e.g. movie, concert.
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public TicketEventType? Type { get; set; }

        /// <summary>
        /// Url to the event info.
        /// </summary>
        [JsonProperty("url", NullValueHandling = NullValueHandling.Ignore)]
        public string Url { get; set; }
    }

    /// <summary>
    /// One event character, e.g. organizer, performer etc.
    /// </summary>
    public partial class TicketEventCharacter
    {
        /// <summary>
        /// Character's images.
        /// </summary>
        [JsonProperty("image", NullValueHandling = NullValueHandling.Ignore)]
        public V2UiElementsImage Image { get; set; }

        /// <summary>
        /// Name of the character.
        /// </summary>
        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Type of the event character, e.g. actor or director.
        /// </summary>
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public EventCharacterType? Type { get; set; }
    }

    /// <summary>
    /// If specified, displays a notification to the user with the specified
    /// title and text. Specifying a notification is a suggestion to
    /// notify and is not guaranteed to result in a notification.
    ///
    /// Optional user notification to display as part of the Order update.
    /// </summary>
    public partial class UserNotification
    {
        /// <summary>
        /// The contents of the notification.
        /// Max allowed length is 100 chars.
        /// </summary>
        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public string Text { get; set; }

        /// <summary>
        /// The title for the user notification.
        /// Max allowed length is 30 chars.
        /// </summary>
        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public string Title { get; set; }
    }

    public partial class Suggestion
    {
        /// <summary>
        /// Required. The text shown in the suggestion chip. When tapped, this text will be
        /// posted back to the conversation verbatim as if the user had typed it.
        /// Each title must be unique among the set of suggestion chips.
        /// Max 25 chars
        /// </summary>
        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public string Title { get; set; }
    }

    public enum Capability { InteractiveCanvas, LongFormAudio, RichResponse, Speech, Unspecified, WebLink };

    /// <summary>
    /// Required. The current status of slot filling. This field is read-only.
    /// </summary>
    public enum SlotFillingStatus { Collecting, Final, Finalizing, Initialized, Unspecified };

    /// <summary>
    /// Required. How this type should be merged with other type values.
    /// </summary>
    public enum Mode { TypeMerge, TypeReplace, TypeUnspecified };

    /// <summary>
    /// Indicates a hint for the url type.
    /// </summary>
    public enum Hint { Amp, LinkUnspecified };

    /// <summary>
    /// Whether the user account is linked to the app.
    /// </summary>
    public enum AccountLinkingStatus { 
        
        
        AccountLinkingStatusUnspecified, Linked, NotLinked };

    /// <summary>
    /// The type of SKU.
    /// </summary>
    public enum SkuType { App, InApp, SkuTypeUnspecified, Subscription };

    /// <summary>
    /// Indicates the verification status of the user.
    /// </summary>
    public enum VerificationStatus { Guest, UserVerificationStatusUnspecified, Verified };

    /// <summary>
    /// How the image background will be filled. Optional.
    ///
    /// How the image backgrounds of collection items will be filled. Optional.
    /// </summary>
    public enum ImageFill { Cropped, Gray, Unspecified, White };

    public enum MediaType { Audio, MediaStatusAck, MediaTypeUnspecified };

    public enum OptionalMediaControl { OptionalMediaControlsUnspecified, Paused, Stopped };

    /// <summary>
    /// Horizontal alignment of content w.r.t column. If unspecified, content
    /// will be aligned to the leading edge.
    /// </summary>
    public enum Align { Center, Leading, Trailing, Unspecified };

    /// <summary>
    /// Presentation requirement of the disclosure.
    /// </summary>
    public enum PresentationRequirement { RequirementOptional, RequirementRequired, RequirementUnspecified };

    /// <summary>
    /// Indicates a hint for the url type.
    /// </summary>
    public enum UrlTypeHint { AmpContent, UrlTypeHintUnspecified };

    /// <summary>
    /// Required: Type of action.
    /// </summary>
    public enum FollowUpActionType { Call, Cancel, CustomerService, Direction, Email, Exchange, FixIssue, Modify, Reorder, Return, Review, TypeUnspecified, ViewDetails };

    /// <summary>
    /// Required: State of the price: Estimate vs Actual.
    /// </summary>
    public enum State { Actual, Estimate, StateUnspecified };

    /// <summary>
    /// Required: Type of money attribute.
    /// </summary>
    public enum PriceAttributeType { Delivery, Discount, Fee, Gratuity, Regular, Subtotal, Tax, Total, TypeUnspecified };

    /// <summary>
    /// Required: The type of fulfillment.
    /// </summary>
    public enum FulfillmentType { Delivery, Pickup, TypeUnspecified };

    /// <summary>
    /// Method used to send checkin instructions.
    /// </summary>
    public enum CheckInType { CheckInTypeUnspecified, Email, Sms };

    /// <summary>
    /// Partners need additional information to facilitate curbside pickup
    /// orders. Depending upon what fulfillment type is chosen, corresponding
    /// details would be collected from the user.
    /// </summary>
    public enum CurbsideFulfillmentType { Unspecified, VehicleDetail };

    /// <summary>
    /// Pick up method, such as INSTORE, CURBSIDE etc.
    /// </summary>
    public enum PickupType { Curbside, Instore, Unspecified };

    /// <summary>
    /// Required: Line item level status.
    ///
    /// Required: Overall Status for the order.
    /// </summary>
    public enum PurchaseStatus { Cancelled, ChangeRequested, Confirmed, Created, Delivered, InPreparation, OutOfStock, PurchaseStatusUnspecified, ReadyForPickup, Rejected, Returned, Shipped };

    /// <summary>
    /// Required: Type of purchase.
    /// </summary>
    public enum PurchaseType { Food, Grocery, MobileRecharge, PurchaseTypeUnspecified, Retail };

    /// <summary>
    /// Unit: Example POUND, GRAM.
    /// </summary>
    public enum Unit { Gram, Kilogram, Milligram, Ounce, Pound, UnitUnspecified };

    /// <summary>
    /// Required: Reservation status.
    /// </summary>
    public enum ReservationStatus { Cancelled, ChangeRequested, Confirmed, Fulfilled, Pending, Rejected, ReservationStatusUnspecified };

    /// <summary>
    /// Type of reservation.
    /// May be unset if none of the type options is applicable.
    /// </summary>
    public enum ReservationType { Hairdresser, ReservationTypeUnspecified, Restaurant };

    /// <summary>
    /// The type of the payment.
    /// </summary>
    public enum PaymentType { Bank, Cash, GiftCard, LoyaltyProgram, PaymentCard, PaymentTypeUnspecified, Wallet };

    /// <summary>
    /// Provenance of the payment method used for the transaction.
    /// User may have registered the same payment method with both google and
    /// merchant.
    /// </summary>
    public enum PaymentMethodProvenance { PaymentMethodProvenanceGoogle, PaymentMethodProvenanceMerchant, PaymentMethodProvenanceUnspecified };

    /// <summary>
    /// Required: This represents the granular reason why an order gets rejected by
    /// the merchant.
    /// </summary>
    public enum ErrorType { AccountLinkingFailed, AvailabilityChanged, Closed, ErrorTypeUnspecified, FailedPrecondition, IncorrectPrice, Ineligible, Invalid, MerchantUnreachable, NoCapacity, NoCourierAvailable, NotFound, OutOfServiceArea, PaymentDeclined, PriceChanged, PromoExpired, PromoNotApplicable, PromoNotRecognized, PromoOrderIneligible, PromoUserIneligible, RequirementsNotMet, TooLate, UnavailableSlot };

    /// <summary>
    /// Location of the purchase (in-store / online)
    /// </summary>
    public enum PurchaseLocationType { InstorePurchase, OnlinePurchase, UnspecifiedLocation };

    /// <summary>
    /// Type of the event character, e.g. actor or director.
    /// </summary>
    public enum EventCharacterType { Actor, Director, Organizer, Performer, TypeUnknown };

    /// <summary>
    /// Required: Type of the ticket event, e.g. movie, concert.
    /// </summary>
    public enum TicketEventType { Concert, EventTypeUnknown, Movie, Sports };

    /// <summary>
    /// Deprecated: Use OrderUpdate.update_mask instead.
    /// If type = SNAPSHOT, OrderUpdate.order should be the entire order.
    /// If type = ORDER_STATUS, this is the order level status change. Only
    /// order.last_update_time and this vertical status are picked up.
    /// Note: type.ORDER_STATUS only supports PurcahaseOrderExtension status
    /// updates and there is no plan to extend this support. Instead, we recommend
    /// using update_mask as it is more generic, extensible and can be used for all
    /// verticals.
    /// </summary>
    public enum OrderUpdateType { OrderStatus, Snapshot, TypeUnspecified };

    public partial class HandlerRequest
    {
        public static HandlerRequest FromJson(string json) => JsonConvert.DeserializeObject<HandlerRequest>(json, Whetstone.Google.Actions.V1.Converter.Settings);

    }

    public partial class HandlerResponse
    {
        public static HandlerResponse FromJson(string json) => JsonConvert.DeserializeObject<HandlerResponse>(json, Whetstone.Google.Actions.V1.Converter.Settings);

    }

    public static class Serialize
    {
        public static string ToJson(this HandlerRequest self) => JsonConvert.SerializeObject(self, Whetstone.Google.Actions.V1.Converter.Settings);

        public static string ToJson(this HandlerResponse self) => JsonConvert.SerializeObject(self, Whetstone.Google.Actions.V1.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            MaxDepth = 30,
            Converters =
            {
                CapabilityConverter.Singleton,
                SlotFillingStatusConverter.Singleton,
                ModeConverter.Singleton,
                HintConverter.Singleton,
                AccountLinkingStatusConverter.Singleton,
                SkuTypeConverter.Singleton,
                VerificationStatusConverter.Singleton,
                ImageFillConverter.Singleton,
                MediaTypeConverter.Singleton,
                OptionalMediaControlConverter.Singleton,
                AlignConverter.Singleton,
                PresentationRequirementConverter.Singleton,
                UrlTypeHintConverter.Singleton,
                FollowUpActionTypeConverter.Singleton,
                StateConverter.Singleton,
                PriceAttributeTypeConverter.Singleton,
                FulfillmentTypeConverter.Singleton,
                CheckInTypeConverter.Singleton,
                CurbsideFulfillmentTypeConverter.Singleton,
                PickupTypeConverter.Singleton,
                PurchaseStatusConverter.Singleton,
                PurchaseTypeConverter.Singleton,
                UnitConverter.Singleton,
                ReservationStatusConverter.Singleton,
                ReservationTypeConverter.Singleton,
                PaymentTypeConverter.Singleton,
                PaymentMethodProvenanceConverter.Singleton,
                ErrorTypeConverter.Singleton,
                PurchaseLocationTypeConverter.Singleton,
                EventCharacterTypeConverter.Singleton,
                TicketEventTypeConverter.Singleton,
                OrderUpdateTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class CapabilityConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Capability) || t == typeof(Capability?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "INTERACTIVE_CANVAS":
                    return Capability.InteractiveCanvas;
                case "LONG_FORM_AUDIO":
                    return Capability.LongFormAudio;
                case "RICH_RESPONSE":
                    return Capability.RichResponse;
                case "SPEECH":
                    return Capability.Speech;
                case "UNSPECIFIED":
                    return Capability.Unspecified;
                case "WEB_LINK":
                    return Capability.WebLink;
            }
            throw new Exception("Cannot unmarshal type Capability");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Capability)untypedValue;
            switch (value)
            {
                case Capability.InteractiveCanvas:
                    serializer.Serialize(writer, "INTERACTIVE_CANVAS");
                    return;
                case Capability.LongFormAudio:
                    serializer.Serialize(writer, "LONG_FORM_AUDIO");
                    return;
                case Capability.RichResponse:
                    serializer.Serialize(writer, "RICH_RESPONSE");
                    return;
                case Capability.Speech:
                    serializer.Serialize(writer, "SPEECH");
                    return;
                case Capability.Unspecified:
                    serializer.Serialize(writer, "UNSPECIFIED");
                    return;
                case Capability.WebLink:
                    serializer.Serialize(writer, "WEB_LINK");
                    return;
            }
            throw new Exception("Cannot marshal type Capability");
        }

        public static readonly CapabilityConverter Singleton = new CapabilityConverter();
    }

    internal class SlotFillingStatusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SlotFillingStatus) || t == typeof(SlotFillingStatus?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "COLLECTING":
                    return SlotFillingStatus.Collecting;
                case "FINAL":
                    return SlotFillingStatus.Final;
                case "FINALIZING":
                    return SlotFillingStatus.Finalizing;
                case "INITIALIZED":
                    return SlotFillingStatus.Initialized;
                case "UNSPECIFIED":
                    return SlotFillingStatus.Unspecified;
            }
            throw new Exception("Cannot unmarshal type SlotFillingStatus");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SlotFillingStatus)untypedValue;
            switch (value)
            {
                case SlotFillingStatus.Collecting:
                    serializer.Serialize(writer, "COLLECTING");
                    return;
                case SlotFillingStatus.Final:
                    serializer.Serialize(writer, "FINAL");
                    return;
                case SlotFillingStatus.Finalizing:
                    serializer.Serialize(writer, "FINALIZING");
                    return;
                case SlotFillingStatus.Initialized:
                    serializer.Serialize(writer, "INITIALIZED");
                    return;
                case SlotFillingStatus.Unspecified:
                    serializer.Serialize(writer, "UNSPECIFIED");
                    return;
            }
            throw new Exception("Cannot marshal type SlotFillingStatus");
        }

        public static readonly SlotFillingStatusConverter Singleton = new SlotFillingStatusConverter();
    }

    internal class ModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Mode) || t == typeof(Mode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "TYPE_MERGE":
                    return Mode.TypeMerge;
                case "TYPE_REPLACE":
                    return Mode.TypeReplace;
                case "TYPE_UNSPECIFIED":
                    return Mode.TypeUnspecified;
            }
            throw new Exception("Cannot unmarshal type Mode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Mode)untypedValue;
            switch (value)
            {
                case Mode.TypeMerge:
                    serializer.Serialize(writer, "TYPE_MERGE");
                    return;
                case Mode.TypeReplace:
                    serializer.Serialize(writer, "TYPE_REPLACE");
                    return;
                case Mode.TypeUnspecified:
                    serializer.Serialize(writer, "TYPE_UNSPECIFIED");
                    return;
            }
            throw new Exception("Cannot marshal type Mode");
        }

        public static readonly ModeConverter Singleton = new ModeConverter();
    }

    internal class HintConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Hint) || t == typeof(Hint?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "AMP":
                    return Hint.Amp;
                case "LINK_UNSPECIFIED":
                    return Hint.LinkUnspecified;
            }
            throw new Exception("Cannot unmarshal type Hint");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Hint)untypedValue;
            switch (value)
            {
                case Hint.Amp:
                    serializer.Serialize(writer, "AMP");
                    return;
                case Hint.LinkUnspecified:
                    serializer.Serialize(writer, "LINK_UNSPECIFIED");
                    return;
            }
            throw new Exception("Cannot marshal type Hint");
        }

        public static readonly HintConverter Singleton = new HintConverter();
    }

    internal class AccountLinkingStatusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AccountLinkingStatus) || t == typeof(AccountLinkingStatus?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ACCOUNT_LINKING_STATUS_UNSPECIFIED":
                    return AccountLinkingStatus.AccountLinkingStatusUnspecified;
                case "LINKED":
                    return AccountLinkingStatus.Linked;
                case "NOT_LINKED":
                    return AccountLinkingStatus.NotLinked;
            }
            throw new Exception("Cannot unmarshal type AccountLinkingStatus");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AccountLinkingStatus)untypedValue;
            switch (value)
            {
                case AccountLinkingStatus.AccountLinkingStatusUnspecified:
                    serializer.Serialize(writer, "ACCOUNT_LINKING_STATUS_UNSPECIFIED");
                    return;
                case AccountLinkingStatus.Linked:
                    serializer.Serialize(writer, "LINKED");
                    return;
                case AccountLinkingStatus.NotLinked:
                    serializer.Serialize(writer, "NOT_LINKED");
                    return;
            }
            throw new Exception("Cannot marshal type AccountLinkingStatus");
        }

        public static readonly AccountLinkingStatusConverter Singleton = new AccountLinkingStatusConverter();
    }

    internal class SkuTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SkuType) || t == typeof(SkuType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "APP":
                    return SkuType.App;
                case "IN_APP":
                    return SkuType.InApp;
                case "SKU_TYPE_UNSPECIFIED":
                    return SkuType.SkuTypeUnspecified;
                case "SUBSCRIPTION":
                    return SkuType.Subscription;
            }
            throw new Exception("Cannot unmarshal type SkuType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SkuType)untypedValue;
            switch (value)
            {
                case SkuType.App:
                    serializer.Serialize(writer, "APP");
                    return;
                case SkuType.InApp:
                    serializer.Serialize(writer, "IN_APP");
                    return;
                case SkuType.SkuTypeUnspecified:
                    serializer.Serialize(writer, "SKU_TYPE_UNSPECIFIED");
                    return;
                case SkuType.Subscription:
                    serializer.Serialize(writer, "SUBSCRIPTION");
                    return;
            }
            throw new Exception("Cannot marshal type SkuType");
        }

        public static readonly SkuTypeConverter Singleton = new SkuTypeConverter();
    }

    internal class VerificationStatusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(VerificationStatus) || t == typeof(VerificationStatus?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "GUEST":
                    return VerificationStatus.Guest;
                case "USER_VERIFICATION_STATUS_UNSPECIFIED":
                    return VerificationStatus.UserVerificationStatusUnspecified;
                case "VERIFIED":
                    return VerificationStatus.Verified;
            }
            throw new Exception("Cannot unmarshal type VerificationStatus");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (VerificationStatus)untypedValue;
            switch (value)
            {
                case VerificationStatus.Guest:
                    serializer.Serialize(writer, "GUEST");
                    return;
                case VerificationStatus.UserVerificationStatusUnspecified:
                    serializer.Serialize(writer, "USER_VERIFICATION_STATUS_UNSPECIFIED");
                    return;
                case VerificationStatus.Verified:
                    serializer.Serialize(writer, "VERIFIED");
                    return;
            }
            throw new Exception("Cannot marshal type VerificationStatus");
        }

        public static readonly VerificationStatusConverter Singleton = new VerificationStatusConverter();
    }

    internal class ImageFillConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ImageFill) || t == typeof(ImageFill?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CROPPED":
                    return ImageFill.Cropped;
                case "GRAY":
                    return ImageFill.Gray;
                case "UNSPECIFIED":
                    return ImageFill.Unspecified;
                case "WHITE":
                    return ImageFill.White;
            }
            throw new Exception("Cannot unmarshal type ImageFill");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ImageFill)untypedValue;
            switch (value)
            {
                case ImageFill.Cropped:
                    serializer.Serialize(writer, "CROPPED");
                    return;
                case ImageFill.Gray:
                    serializer.Serialize(writer, "GRAY");
                    return;
                case ImageFill.Unspecified:
                    serializer.Serialize(writer, "UNSPECIFIED");
                    return;
                case ImageFill.White:
                    serializer.Serialize(writer, "WHITE");
                    return;
            }
            throw new Exception("Cannot marshal type ImageFill");
        }

        public static readonly ImageFillConverter Singleton = new ImageFillConverter();
    }

    internal class MediaTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(MediaType) || t == typeof(MediaType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "AUDIO":
                    return MediaType.Audio;
                case "MEDIA_STATUS_ACK":
                    return MediaType.MediaStatusAck;
                case "MEDIA_TYPE_UNSPECIFIED":
                    return MediaType.MediaTypeUnspecified;
            }
            throw new Exception("Cannot unmarshal type MediaType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (MediaType)untypedValue;
            switch (value)
            {
                case MediaType.Audio:
                    serializer.Serialize(writer, "AUDIO");
                    return;
                case MediaType.MediaStatusAck:
                    serializer.Serialize(writer, "MEDIA_STATUS_ACK");
                    return;
                case MediaType.MediaTypeUnspecified:
                    serializer.Serialize(writer, "MEDIA_TYPE_UNSPECIFIED");
                    return;
            }
            throw new Exception("Cannot marshal type MediaType");
        }

        public static readonly MediaTypeConverter Singleton = new MediaTypeConverter();
    }

    internal class OptionalMediaControlConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OptionalMediaControl) || t == typeof(OptionalMediaControl?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "OPTIONAL_MEDIA_CONTROLS_UNSPECIFIED":
                    return OptionalMediaControl.OptionalMediaControlsUnspecified;
                case "PAUSED":
                    return OptionalMediaControl.Paused;
                case "STOPPED":
                    return OptionalMediaControl.Stopped;
            }
            throw new Exception("Cannot unmarshal type OptionalMediaControl");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OptionalMediaControl)untypedValue;
            switch (value)
            {
                case OptionalMediaControl.OptionalMediaControlsUnspecified:
                    serializer.Serialize(writer, "OPTIONAL_MEDIA_CONTROLS_UNSPECIFIED");
                    return;
                case OptionalMediaControl.Paused:
                    serializer.Serialize(writer, "PAUSED");
                    return;
                case OptionalMediaControl.Stopped:
                    serializer.Serialize(writer, "STOPPED");
                    return;
            }
            throw new Exception("Cannot marshal type OptionalMediaControl");
        }

        public static readonly OptionalMediaControlConverter Singleton = new OptionalMediaControlConverter();
    }

    internal class AlignConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Align) || t == typeof(Align?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CENTER":
                    return Align.Center;
                case "LEADING":
                    return Align.Leading;
                case "TRAILING":
                    return Align.Trailing;
                case "UNSPECIFIED":
                    return Align.Unspecified;
            }
            throw new Exception("Cannot unmarshal type Align");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Align)untypedValue;
            switch (value)
            {
                case Align.Center:
                    serializer.Serialize(writer, "CENTER");
                    return;
                case Align.Leading:
                    serializer.Serialize(writer, "LEADING");
                    return;
                case Align.Trailing:
                    serializer.Serialize(writer, "TRAILING");
                    return;
                case Align.Unspecified:
                    serializer.Serialize(writer, "UNSPECIFIED");
                    return;
            }
            throw new Exception("Cannot marshal type Align");
        }

        public static readonly AlignConverter Singleton = new AlignConverter();
    }

    internal class PresentationRequirementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PresentationRequirement) || t == typeof(PresentationRequirement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "REQUIREMENT_OPTIONAL":
                    return PresentationRequirement.RequirementOptional;
                case "REQUIREMENT_REQUIRED":
                    return PresentationRequirement.RequirementRequired;
                case "REQUIREMENT_UNSPECIFIED":
                    return PresentationRequirement.RequirementUnspecified;
            }
            throw new Exception("Cannot unmarshal type PresentationRequirement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PresentationRequirement)untypedValue;
            switch (value)
            {
                case PresentationRequirement.RequirementOptional:
                    serializer.Serialize(writer, "REQUIREMENT_OPTIONAL");
                    return;
                case PresentationRequirement.RequirementRequired:
                    serializer.Serialize(writer, "REQUIREMENT_REQUIRED");
                    return;
                case PresentationRequirement.RequirementUnspecified:
                    serializer.Serialize(writer, "REQUIREMENT_UNSPECIFIED");
                    return;
            }
            throw new Exception("Cannot marshal type PresentationRequirement");
        }

        public static readonly PresentationRequirementConverter Singleton = new PresentationRequirementConverter();
    }

    internal class UrlTypeHintConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(UrlTypeHint) || t == typeof(UrlTypeHint?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "AMP_CONTENT":
                    return UrlTypeHint.AmpContent;
                case "URL_TYPE_HINT_UNSPECIFIED":
                    return UrlTypeHint.UrlTypeHintUnspecified;
            }
            throw new Exception("Cannot unmarshal type UrlTypeHint");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (UrlTypeHint)untypedValue;
            switch (value)
            {
                case UrlTypeHint.AmpContent:
                    serializer.Serialize(writer, "AMP_CONTENT");
                    return;
                case UrlTypeHint.UrlTypeHintUnspecified:
                    serializer.Serialize(writer, "URL_TYPE_HINT_UNSPECIFIED");
                    return;
            }
            throw new Exception("Cannot marshal type UrlTypeHint");
        }

        public static readonly UrlTypeHintConverter Singleton = new UrlTypeHintConverter();
    }

    internal class FollowUpActionTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FollowUpActionType) || t == typeof(FollowUpActionType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CALL":
                    return FollowUpActionType.Call;
                case "CANCEL":
                    return FollowUpActionType.Cancel;
                case "CUSTOMER_SERVICE":
                    return FollowUpActionType.CustomerService;
                case "DIRECTION":
                    return FollowUpActionType.Direction;
                case "EMAIL":
                    return FollowUpActionType.Email;
                case "EXCHANGE":
                    return FollowUpActionType.Exchange;
                case "FIX_ISSUE":
                    return FollowUpActionType.FixIssue;
                case "MODIFY":
                    return FollowUpActionType.Modify;
                case "REORDER":
                    return FollowUpActionType.Reorder;
                case "RETURN":
                    return FollowUpActionType.Return;
                case "REVIEW":
                    return FollowUpActionType.Review;
                case "TYPE_UNSPECIFIED":
                    return FollowUpActionType.TypeUnspecified;
                case "VIEW_DETAILS":
                    return FollowUpActionType.ViewDetails;
            }
            throw new Exception("Cannot unmarshal type FollowUpActionType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FollowUpActionType)untypedValue;
            switch (value)
            {
                case FollowUpActionType.Call:
                    serializer.Serialize(writer, "CALL");
                    return;
                case FollowUpActionType.Cancel:
                    serializer.Serialize(writer, "CANCEL");
                    return;
                case FollowUpActionType.CustomerService:
                    serializer.Serialize(writer, "CUSTOMER_SERVICE");
                    return;
                case FollowUpActionType.Direction:
                    serializer.Serialize(writer, "DIRECTION");
                    return;
                case FollowUpActionType.Email:
                    serializer.Serialize(writer, "EMAIL");
                    return;
                case FollowUpActionType.Exchange:
                    serializer.Serialize(writer, "EXCHANGE");
                    return;
                case FollowUpActionType.FixIssue:
                    serializer.Serialize(writer, "FIX_ISSUE");
                    return;
                case FollowUpActionType.Modify:
                    serializer.Serialize(writer, "MODIFY");
                    return;
                case FollowUpActionType.Reorder:
                    serializer.Serialize(writer, "REORDER");
                    return;
                case FollowUpActionType.Return:
                    serializer.Serialize(writer, "RETURN");
                    return;
                case FollowUpActionType.Review:
                    serializer.Serialize(writer, "REVIEW");
                    return;
                case FollowUpActionType.TypeUnspecified:
                    serializer.Serialize(writer, "TYPE_UNSPECIFIED");
                    return;
                case FollowUpActionType.ViewDetails:
                    serializer.Serialize(writer, "VIEW_DETAILS");
                    return;
            }
            throw new Exception("Cannot marshal type FollowUpActionType");
        }

        public static readonly FollowUpActionTypeConverter Singleton = new FollowUpActionTypeConverter();
    }

    internal class StateConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(State) || t == typeof(State?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ACTUAL":
                    return State.Actual;
                case "ESTIMATE":
                    return State.Estimate;
                case "STATE_UNSPECIFIED":
                    return State.StateUnspecified;
            }
            throw new Exception("Cannot unmarshal type State");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (State)untypedValue;
            switch (value)
            {
                case State.Actual:
                    serializer.Serialize(writer, "ACTUAL");
                    return;
                case State.Estimate:
                    serializer.Serialize(writer, "ESTIMATE");
                    return;
                case State.StateUnspecified:
                    serializer.Serialize(writer, "STATE_UNSPECIFIED");
                    return;
            }
            throw new Exception("Cannot marshal type State");
        }

        public static readonly StateConverter Singleton = new StateConverter();
    }

    internal class PriceAttributeTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PriceAttributeType) || t == typeof(PriceAttributeType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "DELIVERY":
                    return PriceAttributeType.Delivery;
                case "DISCOUNT":
                    return PriceAttributeType.Discount;
                case "FEE":
                    return PriceAttributeType.Fee;
                case "GRATUITY":
                    return PriceAttributeType.Gratuity;
                case "REGULAR":
                    return PriceAttributeType.Regular;
                case "SUBTOTAL":
                    return PriceAttributeType.Subtotal;
                case "TAX":
                    return PriceAttributeType.Tax;
                case "TOTAL":
                    return PriceAttributeType.Total;
                case "TYPE_UNSPECIFIED":
                    return PriceAttributeType.TypeUnspecified;
            }
            throw new Exception("Cannot unmarshal type PriceAttributeType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PriceAttributeType)untypedValue;
            switch (value)
            {
                case PriceAttributeType.Delivery:
                    serializer.Serialize(writer, "DELIVERY");
                    return;
                case PriceAttributeType.Discount:
                    serializer.Serialize(writer, "DISCOUNT");
                    return;
                case PriceAttributeType.Fee:
                    serializer.Serialize(writer, "FEE");
                    return;
                case PriceAttributeType.Gratuity:
                    serializer.Serialize(writer, "GRATUITY");
                    return;
                case PriceAttributeType.Regular:
                    serializer.Serialize(writer, "REGULAR");
                    return;
                case PriceAttributeType.Subtotal:
                    serializer.Serialize(writer, "SUBTOTAL");
                    return;
                case PriceAttributeType.Tax:
                    serializer.Serialize(writer, "TAX");
                    return;
                case PriceAttributeType.Total:
                    serializer.Serialize(writer, "TOTAL");
                    return;
                case PriceAttributeType.TypeUnspecified:
                    serializer.Serialize(writer, "TYPE_UNSPECIFIED");
                    return;
            }
            throw new Exception("Cannot marshal type PriceAttributeType");
        }

        public static readonly PriceAttributeTypeConverter Singleton = new PriceAttributeTypeConverter();
    }

    internal class FulfillmentTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FulfillmentType) || t == typeof(FulfillmentType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "DELIVERY":
                    return FulfillmentType.Delivery;
                case "PICKUP":
                    return FulfillmentType.Pickup;
                case "TYPE_UNSPECIFIED":
                    return FulfillmentType.TypeUnspecified;
            }
            throw new Exception("Cannot unmarshal type FulfillmentType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FulfillmentType)untypedValue;
            switch (value)
            {
                case FulfillmentType.Delivery:
                    serializer.Serialize(writer, "DELIVERY");
                    return;
                case FulfillmentType.Pickup:
                    serializer.Serialize(writer, "PICKUP");
                    return;
                case FulfillmentType.TypeUnspecified:
                    serializer.Serialize(writer, "TYPE_UNSPECIFIED");
                    return;
            }
            throw new Exception("Cannot marshal type FulfillmentType");
        }

        public static readonly FulfillmentTypeConverter Singleton = new FulfillmentTypeConverter();
    }

    internal class CheckInTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CheckInType) || t == typeof(CheckInType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CHECK_IN_TYPE_UNSPECIFIED":
                    return CheckInType.CheckInTypeUnspecified;
                case "EMAIL":
                    return CheckInType.Email;
                case "SMS":
                    return CheckInType.Sms;
            }
            throw new Exception("Cannot unmarshal type CheckInType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CheckInType)untypedValue;
            switch (value)
            {
                case CheckInType.CheckInTypeUnspecified:
                    serializer.Serialize(writer, "CHECK_IN_TYPE_UNSPECIFIED");
                    return;
                case CheckInType.Email:
                    serializer.Serialize(writer, "EMAIL");
                    return;
                case CheckInType.Sms:
                    serializer.Serialize(writer, "SMS");
                    return;
            }
            throw new Exception("Cannot marshal type CheckInType");
        }

        public static readonly CheckInTypeConverter Singleton = new CheckInTypeConverter();
    }

    internal class CurbsideFulfillmentTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CurbsideFulfillmentType) || t == typeof(CurbsideFulfillmentType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "UNSPECIFIED":
                    return CurbsideFulfillmentType.Unspecified;
                case "VEHICLE_DETAIL":
                    return CurbsideFulfillmentType.VehicleDetail;
            }
            throw new Exception("Cannot unmarshal type CurbsideFulfillmentType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CurbsideFulfillmentType)untypedValue;
            switch (value)
            {
                case CurbsideFulfillmentType.Unspecified:
                    serializer.Serialize(writer, "UNSPECIFIED");
                    return;
                case CurbsideFulfillmentType.VehicleDetail:
                    serializer.Serialize(writer, "VEHICLE_DETAIL");
                    return;
            }
            throw new Exception("Cannot marshal type CurbsideFulfillmentType");
        }

        public static readonly CurbsideFulfillmentTypeConverter Singleton = new CurbsideFulfillmentTypeConverter();
    }

    internal class PickupTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PickupType) || t == typeof(PickupType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CURBSIDE":
                    return PickupType.Curbside;
                case "INSTORE":
                    return PickupType.Instore;
                case "UNSPECIFIED":
                    return PickupType.Unspecified;
            }
            throw new Exception("Cannot unmarshal type PickupType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PickupType)untypedValue;
            switch (value)
            {
                case PickupType.Curbside:
                    serializer.Serialize(writer, "CURBSIDE");
                    return;
                case PickupType.Instore:
                    serializer.Serialize(writer, "INSTORE");
                    return;
                case PickupType.Unspecified:
                    serializer.Serialize(writer, "UNSPECIFIED");
                    return;
            }
            throw new Exception("Cannot marshal type PickupType");
        }

        public static readonly PickupTypeConverter Singleton = new PickupTypeConverter();
    }

    internal class PurchaseStatusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PurchaseStatus) || t == typeof(PurchaseStatus?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CANCELLED":
                    return PurchaseStatus.Cancelled;
                case "CHANGE_REQUESTED":
                    return PurchaseStatus.ChangeRequested;
                case "CONFIRMED":
                    return PurchaseStatus.Confirmed;
                case "CREATED":
                    return PurchaseStatus.Created;
                case "DELIVERED":
                    return PurchaseStatus.Delivered;
                case "IN_PREPARATION":
                    return PurchaseStatus.InPreparation;
                case "OUT_OF_STOCK":
                    return PurchaseStatus.OutOfStock;
                case "PURCHASE_STATUS_UNSPECIFIED":
                    return PurchaseStatus.PurchaseStatusUnspecified;
                case "READY_FOR_PICKUP":
                    return PurchaseStatus.ReadyForPickup;
                case "REJECTED":
                    return PurchaseStatus.Rejected;
                case "RETURNED":
                    return PurchaseStatus.Returned;
                case "SHIPPED":
                    return PurchaseStatus.Shipped;
            }
            throw new Exception("Cannot unmarshal type PurchaseStatus");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PurchaseStatus)untypedValue;
            switch (value)
            {
                case PurchaseStatus.Cancelled:
                    serializer.Serialize(writer, "CANCELLED");
                    return;
                case PurchaseStatus.ChangeRequested:
                    serializer.Serialize(writer, "CHANGE_REQUESTED");
                    return;
                case PurchaseStatus.Confirmed:
                    serializer.Serialize(writer, "CONFIRMED");
                    return;
                case PurchaseStatus.Created:
                    serializer.Serialize(writer, "CREATED");
                    return;
                case PurchaseStatus.Delivered:
                    serializer.Serialize(writer, "DELIVERED");
                    return;
                case PurchaseStatus.InPreparation:
                    serializer.Serialize(writer, "IN_PREPARATION");
                    return;
                case PurchaseStatus.OutOfStock:
                    serializer.Serialize(writer, "OUT_OF_STOCK");
                    return;
                case PurchaseStatus.PurchaseStatusUnspecified:
                    serializer.Serialize(writer, "PURCHASE_STATUS_UNSPECIFIED");
                    return;
                case PurchaseStatus.ReadyForPickup:
                    serializer.Serialize(writer, "READY_FOR_PICKUP");
                    return;
                case PurchaseStatus.Rejected:
                    serializer.Serialize(writer, "REJECTED");
                    return;
                case PurchaseStatus.Returned:
                    serializer.Serialize(writer, "RETURNED");
                    return;
                case PurchaseStatus.Shipped:
                    serializer.Serialize(writer, "SHIPPED");
                    return;
            }
            throw new Exception("Cannot marshal type PurchaseStatus");
        }

        public static readonly PurchaseStatusConverter Singleton = new PurchaseStatusConverter();
    }

    internal class PurchaseTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PurchaseType) || t == typeof(PurchaseType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "FOOD":
                    return PurchaseType.Food;
                case "GROCERY":
                    return PurchaseType.Grocery;
                case "MOBILE_RECHARGE":
                    return PurchaseType.MobileRecharge;
                case "PURCHASE_TYPE_UNSPECIFIED":
                    return PurchaseType.PurchaseTypeUnspecified;
                case "RETAIL":
                    return PurchaseType.Retail;
            }
            throw new Exception("Cannot unmarshal type PurchaseType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PurchaseType)untypedValue;
            switch (value)
            {
                case PurchaseType.Food:
                    serializer.Serialize(writer, "FOOD");
                    return;
                case PurchaseType.Grocery:
                    serializer.Serialize(writer, "GROCERY");
                    return;
                case PurchaseType.MobileRecharge:
                    serializer.Serialize(writer, "MOBILE_RECHARGE");
                    return;
                case PurchaseType.PurchaseTypeUnspecified:
                    serializer.Serialize(writer, "PURCHASE_TYPE_UNSPECIFIED");
                    return;
                case PurchaseType.Retail:
                    serializer.Serialize(writer, "RETAIL");
                    return;
            }
            throw new Exception("Cannot marshal type PurchaseType");
        }

        public static readonly PurchaseTypeConverter Singleton = new PurchaseTypeConverter();
    }

    internal class UnitConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Unit) || t == typeof(Unit?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "GRAM":
                    return Unit.Gram;
                case "KILOGRAM":
                    return Unit.Kilogram;
                case "MILLIGRAM":
                    return Unit.Milligram;
                case "OUNCE":
                    return Unit.Ounce;
                case "POUND":
                    return Unit.Pound;
                case "UNIT_UNSPECIFIED":
                    return Unit.UnitUnspecified;
            }
            throw new Exception("Cannot unmarshal type Unit");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Unit)untypedValue;
            switch (value)
            {
                case Unit.Gram:
                    serializer.Serialize(writer, "GRAM");
                    return;
                case Unit.Kilogram:
                    serializer.Serialize(writer, "KILOGRAM");
                    return;
                case Unit.Milligram:
                    serializer.Serialize(writer, "MILLIGRAM");
                    return;
                case Unit.Ounce:
                    serializer.Serialize(writer, "OUNCE");
                    return;
                case Unit.Pound:
                    serializer.Serialize(writer, "POUND");
                    return;
                case Unit.UnitUnspecified:
                    serializer.Serialize(writer, "UNIT_UNSPECIFIED");
                    return;
            }
            throw new Exception("Cannot marshal type Unit");
        }

        public static readonly UnitConverter Singleton = new UnitConverter();
    }

    internal class ReservationStatusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ReservationStatus) || t == typeof(ReservationStatus?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CANCELLED":
                    return ReservationStatus.Cancelled;
                case "CHANGE_REQUESTED":
                    return ReservationStatus.ChangeRequested;
                case "CONFIRMED":
                    return ReservationStatus.Confirmed;
                case "FULFILLED":
                    return ReservationStatus.Fulfilled;
                case "PENDING":
                    return ReservationStatus.Pending;
                case "REJECTED":
                    return ReservationStatus.Rejected;
                case "RESERVATION_STATUS_UNSPECIFIED":
                    return ReservationStatus.ReservationStatusUnspecified;
            }
            throw new Exception("Cannot unmarshal type ReservationStatus");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ReservationStatus)untypedValue;
            switch (value)
            {
                case ReservationStatus.Cancelled:
                    serializer.Serialize(writer, "CANCELLED");
                    return;
                case ReservationStatus.ChangeRequested:
                    serializer.Serialize(writer, "CHANGE_REQUESTED");
                    return;
                case ReservationStatus.Confirmed:
                    serializer.Serialize(writer, "CONFIRMED");
                    return;
                case ReservationStatus.Fulfilled:
                    serializer.Serialize(writer, "FULFILLED");
                    return;
                case ReservationStatus.Pending:
                    serializer.Serialize(writer, "PENDING");
                    return;
                case ReservationStatus.Rejected:
                    serializer.Serialize(writer, "REJECTED");
                    return;
                case ReservationStatus.ReservationStatusUnspecified:
                    serializer.Serialize(writer, "RESERVATION_STATUS_UNSPECIFIED");
                    return;
            }
            throw new Exception("Cannot marshal type ReservationStatus");
        }

        public static readonly ReservationStatusConverter Singleton = new ReservationStatusConverter();
    }

    internal class ReservationTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ReservationType) || t == typeof(ReservationType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "HAIRDRESSER":
                    return ReservationType.Hairdresser;
                case "RESERVATION_TYPE_UNSPECIFIED":
                    return ReservationType.ReservationTypeUnspecified;
                case "RESTAURANT":
                    return ReservationType.Restaurant;
            }
            throw new Exception("Cannot unmarshal type ReservationType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ReservationType)untypedValue;
            switch (value)
            {
                case ReservationType.Hairdresser:
                    serializer.Serialize(writer, "HAIRDRESSER");
                    return;
                case ReservationType.ReservationTypeUnspecified:
                    serializer.Serialize(writer, "RESERVATION_TYPE_UNSPECIFIED");
                    return;
                case ReservationType.Restaurant:
                    serializer.Serialize(writer, "RESTAURANT");
                    return;
            }
            throw new Exception("Cannot marshal type ReservationType");
        }

        public static readonly ReservationTypeConverter Singleton = new ReservationTypeConverter();
    }

    internal class PaymentTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PaymentType) || t == typeof(PaymentType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "BANK":
                    return PaymentType.Bank;
                case "CASH":
                    return PaymentType.Cash;
                case "GIFT_CARD":
                    return PaymentType.GiftCard;
                case "LOYALTY_PROGRAM":
                    return PaymentType.LoyaltyProgram;
                case "PAYMENT_CARD":
                    return PaymentType.PaymentCard;
                case "PAYMENT_TYPE_UNSPECIFIED":
                    return PaymentType.PaymentTypeUnspecified;
                case "WALLET":
                    return PaymentType.Wallet;
            }
            throw new Exception("Cannot unmarshal type PaymentType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PaymentType)untypedValue;
            switch (value)
            {
                case PaymentType.Bank:
                    serializer.Serialize(writer, "BANK");
                    return;
                case PaymentType.Cash:
                    serializer.Serialize(writer, "CASH");
                    return;
                case PaymentType.GiftCard:
                    serializer.Serialize(writer, "GIFT_CARD");
                    return;
                case PaymentType.LoyaltyProgram:
                    serializer.Serialize(writer, "LOYALTY_PROGRAM");
                    return;
                case PaymentType.PaymentCard:
                    serializer.Serialize(writer, "PAYMENT_CARD");
                    return;
                case PaymentType.PaymentTypeUnspecified:
                    serializer.Serialize(writer, "PAYMENT_TYPE_UNSPECIFIED");
                    return;
                case PaymentType.Wallet:
                    serializer.Serialize(writer, "WALLET");
                    return;
            }
            throw new Exception("Cannot marshal type PaymentType");
        }

        public static readonly PaymentTypeConverter Singleton = new PaymentTypeConverter();
    }

    internal class PaymentMethodProvenanceConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PaymentMethodProvenance) || t == typeof(PaymentMethodProvenance?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "PAYMENT_METHOD_PROVENANCE_GOOGLE":
                    return PaymentMethodProvenance.PaymentMethodProvenanceGoogle;
                case "PAYMENT_METHOD_PROVENANCE_MERCHANT":
                    return PaymentMethodProvenance.PaymentMethodProvenanceMerchant;
                case "PAYMENT_METHOD_PROVENANCE_UNSPECIFIED":
                    return PaymentMethodProvenance.PaymentMethodProvenanceUnspecified;
            }
            throw new Exception("Cannot unmarshal type PaymentMethodProvenance");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PaymentMethodProvenance)untypedValue;
            switch (value)
            {
                case PaymentMethodProvenance.PaymentMethodProvenanceGoogle:
                    serializer.Serialize(writer, "PAYMENT_METHOD_PROVENANCE_GOOGLE");
                    return;
                case PaymentMethodProvenance.PaymentMethodProvenanceMerchant:
                    serializer.Serialize(writer, "PAYMENT_METHOD_PROVENANCE_MERCHANT");
                    return;
                case PaymentMethodProvenance.PaymentMethodProvenanceUnspecified:
                    serializer.Serialize(writer, "PAYMENT_METHOD_PROVENANCE_UNSPECIFIED");
                    return;
            }
            throw new Exception("Cannot marshal type PaymentMethodProvenance");
        }

        public static readonly PaymentMethodProvenanceConverter Singleton = new PaymentMethodProvenanceConverter();
    }

    internal class ErrorTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ErrorType) || t == typeof(ErrorType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ACCOUNT_LINKING_FAILED":
                    return ErrorType.AccountLinkingFailed;
                case "AVAILABILITY_CHANGED":
                    return ErrorType.AvailabilityChanged;
                case "CLOSED":
                    return ErrorType.Closed;
                case "ERROR_TYPE_UNSPECIFIED":
                    return ErrorType.ErrorTypeUnspecified;
                case "FAILED_PRECONDITION":
                    return ErrorType.FailedPrecondition;
                case "INCORRECT_PRICE":
                    return ErrorType.IncorrectPrice;
                case "INELIGIBLE":
                    return ErrorType.Ineligible;
                case "INVALID":
                    return ErrorType.Invalid;
                case "MERCHANT_UNREACHABLE":
                    return ErrorType.MerchantUnreachable;
                case "NOT_FOUND":
                    return ErrorType.NotFound;
                case "NO_CAPACITY":
                    return ErrorType.NoCapacity;
                case "NO_COURIER_AVAILABLE":
                    return ErrorType.NoCourierAvailable;
                case "OUT_OF_SERVICE_AREA":
                    return ErrorType.OutOfServiceArea;
                case "PAYMENT_DECLINED":
                    return ErrorType.PaymentDeclined;
                case "PRICE_CHANGED":
                    return ErrorType.PriceChanged;
                case "PROMO_EXPIRED":
                    return ErrorType.PromoExpired;
                case "PROMO_NOT_APPLICABLE":
                    return ErrorType.PromoNotApplicable;
                case "PROMO_NOT_RECOGNIZED":
                    return ErrorType.PromoNotRecognized;
                case "PROMO_ORDER_INELIGIBLE":
                    return ErrorType.PromoOrderIneligible;
                case "PROMO_USER_INELIGIBLE":
                    return ErrorType.PromoUserIneligible;
                case "REQUIREMENTS_NOT_MET":
                    return ErrorType.RequirementsNotMet;
                case "TOO_LATE":
                    return ErrorType.TooLate;
                case "UNAVAILABLE_SLOT":
                    return ErrorType.UnavailableSlot;
            }
            throw new Exception("Cannot unmarshal type ErrorType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ErrorType)untypedValue;
            switch (value)
            {
                case ErrorType.AccountLinkingFailed:
                    serializer.Serialize(writer, "ACCOUNT_LINKING_FAILED");
                    return;
                case ErrorType.AvailabilityChanged:
                    serializer.Serialize(writer, "AVAILABILITY_CHANGED");
                    return;
                case ErrorType.Closed:
                    serializer.Serialize(writer, "CLOSED");
                    return;
                case ErrorType.ErrorTypeUnspecified:
                    serializer.Serialize(writer, "ERROR_TYPE_UNSPECIFIED");
                    return;
                case ErrorType.FailedPrecondition:
                    serializer.Serialize(writer, "FAILED_PRECONDITION");
                    return;
                case ErrorType.IncorrectPrice:
                    serializer.Serialize(writer, "INCORRECT_PRICE");
                    return;
                case ErrorType.Ineligible:
                    serializer.Serialize(writer, "INELIGIBLE");
                    return;
                case ErrorType.Invalid:
                    serializer.Serialize(writer, "INVALID");
                    return;
                case ErrorType.MerchantUnreachable:
                    serializer.Serialize(writer, "MERCHANT_UNREACHABLE");
                    return;
                case ErrorType.NotFound:
                    serializer.Serialize(writer, "NOT_FOUND");
                    return;
                case ErrorType.NoCapacity:
                    serializer.Serialize(writer, "NO_CAPACITY");
                    return;
                case ErrorType.NoCourierAvailable:
                    serializer.Serialize(writer, "NO_COURIER_AVAILABLE");
                    return;
                case ErrorType.OutOfServiceArea:
                    serializer.Serialize(writer, "OUT_OF_SERVICE_AREA");
                    return;
                case ErrorType.PaymentDeclined:
                    serializer.Serialize(writer, "PAYMENT_DECLINED");
                    return;
                case ErrorType.PriceChanged:
                    serializer.Serialize(writer, "PRICE_CHANGED");
                    return;
                case ErrorType.PromoExpired:
                    serializer.Serialize(writer, "PROMO_EXPIRED");
                    return;
                case ErrorType.PromoNotApplicable:
                    serializer.Serialize(writer, "PROMO_NOT_APPLICABLE");
                    return;
                case ErrorType.PromoNotRecognized:
                    serializer.Serialize(writer, "PROMO_NOT_RECOGNIZED");
                    return;
                case ErrorType.PromoOrderIneligible:
                    serializer.Serialize(writer, "PROMO_ORDER_INELIGIBLE");
                    return;
                case ErrorType.PromoUserIneligible:
                    serializer.Serialize(writer, "PROMO_USER_INELIGIBLE");
                    return;
                case ErrorType.RequirementsNotMet:
                    serializer.Serialize(writer, "REQUIREMENTS_NOT_MET");
                    return;
                case ErrorType.TooLate:
                    serializer.Serialize(writer, "TOO_LATE");
                    return;
                case ErrorType.UnavailableSlot:
                    serializer.Serialize(writer, "UNAVAILABLE_SLOT");
                    return;
            }
            throw new Exception("Cannot marshal type ErrorType");
        }

        public static readonly ErrorTypeConverter Singleton = new ErrorTypeConverter();
    }

    internal class PurchaseLocationTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PurchaseLocationType) || t == typeof(PurchaseLocationType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "INSTORE_PURCHASE":
                    return PurchaseLocationType.InstorePurchase;
                case "ONLINE_PURCHASE":
                    return PurchaseLocationType.OnlinePurchase;
                case "UNSPECIFIED_LOCATION":
                    return PurchaseLocationType.UnspecifiedLocation;
            }
            throw new Exception("Cannot unmarshal type PurchaseLocationType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PurchaseLocationType)untypedValue;
            switch (value)
            {
                case PurchaseLocationType.InstorePurchase:
                    serializer.Serialize(writer, "INSTORE_PURCHASE");
                    return;
                case PurchaseLocationType.OnlinePurchase:
                    serializer.Serialize(writer, "ONLINE_PURCHASE");
                    return;
                case PurchaseLocationType.UnspecifiedLocation:
                    serializer.Serialize(writer, "UNSPECIFIED_LOCATION");
                    return;
            }
            throw new Exception("Cannot marshal type PurchaseLocationType");
        }

        public static readonly PurchaseLocationTypeConverter Singleton = new PurchaseLocationTypeConverter();
    }

    internal class EventCharacterTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(EventCharacterType) || t == typeof(EventCharacterType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ACTOR":
                    return EventCharacterType.Actor;
                case "DIRECTOR":
                    return EventCharacterType.Director;
                case "ORGANIZER":
                    return EventCharacterType.Organizer;
                case "PERFORMER":
                    return EventCharacterType.Performer;
                case "TYPE_UNKNOWN":
                    return EventCharacterType.TypeUnknown;
            }
            throw new Exception("Cannot unmarshal type EventCharacterType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (EventCharacterType)untypedValue;
            switch (value)
            {
                case EventCharacterType.Actor:
                    serializer.Serialize(writer, "ACTOR");
                    return;
                case EventCharacterType.Director:
                    serializer.Serialize(writer, "DIRECTOR");
                    return;
                case EventCharacterType.Organizer:
                    serializer.Serialize(writer, "ORGANIZER");
                    return;
                case EventCharacterType.Performer:
                    serializer.Serialize(writer, "PERFORMER");
                    return;
                case EventCharacterType.TypeUnknown:
                    serializer.Serialize(writer, "TYPE_UNKNOWN");
                    return;
            }
            throw new Exception("Cannot marshal type EventCharacterType");
        }

        public static readonly EventCharacterTypeConverter Singleton = new EventCharacterTypeConverter();
    }

    internal class TicketEventTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TicketEventType) || t == typeof(TicketEventType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CONCERT":
                    return TicketEventType.Concert;
                case "EVENT_TYPE_UNKNOWN":
                    return TicketEventType.EventTypeUnknown;
                case "MOVIE":
                    return TicketEventType.Movie;
                case "SPORTS":
                    return TicketEventType.Sports;
            }
            throw new Exception("Cannot unmarshal type TicketEventType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TicketEventType)untypedValue;
            switch (value)
            {
                case TicketEventType.Concert:
                    serializer.Serialize(writer, "CONCERT");
                    return;
                case TicketEventType.EventTypeUnknown:
                    serializer.Serialize(writer, "EVENT_TYPE_UNKNOWN");
                    return;
                case TicketEventType.Movie:
                    serializer.Serialize(writer, "MOVIE");
                    return;
                case TicketEventType.Sports:
                    serializer.Serialize(writer, "SPORTS");
                    return;
            }
            throw new Exception("Cannot marshal type TicketEventType");
        }

        public static readonly TicketEventTypeConverter Singleton = new TicketEventTypeConverter();
    }

    internal class OrderUpdateTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OrderUpdateType) || t == typeof(OrderUpdateType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ORDER_STATUS":
                    return OrderUpdateType.OrderStatus;
                case "SNAPSHOT":
                    return OrderUpdateType.Snapshot;
                case "TYPE_UNSPECIFIED":
                    return OrderUpdateType.TypeUnspecified;
            }
            throw new Exception("Cannot unmarshal type OrderUpdateType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OrderUpdateType)untypedValue;
            switch (value)
            {
                case OrderUpdateType.OrderStatus:
                    serializer.Serialize(writer, "ORDER_STATUS");
                    return;
                case OrderUpdateType.Snapshot:
                    serializer.Serialize(writer, "SNAPSHOT");
                    return;
                case OrderUpdateType.TypeUnspecified:
                    serializer.Serialize(writer, "TYPE_UNSPECIFIED");
                    return;
            }
            throw new Exception("Cannot marshal type OrderUpdateType");
        }

        public static readonly OrderUpdateTypeConverter Singleton = new OrderUpdateTypeConverter();
    }
}
